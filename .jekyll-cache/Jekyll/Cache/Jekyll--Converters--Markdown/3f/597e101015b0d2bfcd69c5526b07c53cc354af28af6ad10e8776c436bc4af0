I"‰¨<div style="background-color: #EAEFF4; border: 1px solid #b5aeb1; border-radius: 3px;  padding: 10px; margin-right: 10px">
    <strong>Vorlesung:</strong> <a href="https://campus.studium.kit.edu/ev/G6hOdkEyRGaMJ98tdLHvGw">Telematik</a>, Stammmodul, 6 ECTS <br />
    <strong>Dozent:</strong> Prof. Dr. Zitterbart <br />
   <strong>ILIAS:</strong> <a href="https://ilias.studium.kit.edu/goto_produktiv_crs_880989.html">https://ilias.studium.kit.edu/goto_produktiv_crs_880989.html</a> <br />   
   <strong>Vorlesungswebsite:</strong> <a href="http://telematics.tm.kit.edu/tm.php">http://telematics.tm.kit.edu/tm.php</a> <br />   
   <strong>Klausur:</strong> 21.2.2019 11:00 - 12:30 Uhr <br />
   <strong>Einordnung:</strong> Vertiefungsfach "Telematik", Profil "Datenintensives Rechnen" <br />
</div>

<h2 id="organisatorisches">Organisatorisches</h2>

<h3 id="vorlesungen">Vorlesungen</h3>
<ul>
  <li><strong>17.10.2018</strong>: Organisatorisches und Foliensatz 1-1 bis 2-20</li>
  <li><strong>18.10.2018</strong>: Foliensatz 2-20 bis 2-63</li>
  <li><strong>24.10.2018</strong>: Foliensatz 2-64 bis 3-12 und Besprechung Homework 1</li>
  <li><strong>25.10.2018</strong>: Foliensatz 3-13 bis 3-53</li>
  <li><strong>31.10.2018</strong>: Foliensatz 3-54 bis 3-100</li>
  <li><strong>07.11.2018</strong>: Foliensatz 3-101 bis 3-135</li>
  <li><strong>08.11.2018</strong>: Foliensatz 3-135 bis 3-154, 4-1 bis 4-16</li>
  <li><strong>14.11.2018</strong>: Foliensatz 4-17 bis 4-77, 5-1 bis 5-28</li>
  <li><strong>15.11.2018</strong>: Foliensatz 5-29 bis 5-103</li>
  <li><strong>21.11.2018</strong>: Foliensatz 5-104 bis 5-165</li>
  <li><strong>22.11.2018</strong>: Foliensatz 5-166 bis 5-213; 6-1 bis 6-34</li>
  <li><strong>22.11.2018</strong>: Foliensatz 7-1 bis 7-45</li>
</ul>

<h3 id="material">Material</h3>
<p>Das Material der Vorlesung besteht aus:</p>
<ul>
  <li><strong>Folien</strong>: Folien werden im ILIAS hochgeladen, Passwort wurde in der Vorlesung mitgeteilt</li>
  <li><strong>√úbungsbl√§ttern</strong><br />
Inhaltlich werden Grundlagen der Rechnernetze vorausgesetzt, Inhaltlich geht es um Technologien des Internets;
Kein spezielles Bucht auf dem VL aufbaut, da gute Standardwerke. Folien auf Englisch um Inhalt einheitlich zu
halten; VL wird durch Pingo, Kahoot und Homework interaktiv gestaltet;
Ende der Vorlesung voraussichtlich bereits ca. 16./17.1.2019</li>
</ul>

<h3 id="√ºbungen">√úbungen</h3>
<p>Homework wird jeweils in der zweiten H√§lfte der VL besprochen, das Blatt dazu gibt es in der Regele ‚Äúbisschen‚Äù fr√ºher;
teilweise mit Programmieraufgaben, keine komplette Musterl√∂sung nur Ergebnis.</p>

<h3 id="klausur">Klausur</h3>
<p>Klausur ist schriftlich; am 21.2.2019 von 11:00 bis 12:30; Fragen in Deutsch, Antworten auf Deutsch und Englisch m√∂glich</p>

<h2 id="vorlesungsinhalt">Vorlesungsinhalt</h2>
<h3 id="introduction">Introduction</h3>
<p><strong>Internet:</strong> largest system build by mankind; Critical Infrastructure e.g. critical infrastructures (water, electricity) depend on the internet;<br />
rapid development (less than 50 years):</p>
<ul>
  <li>early 60s: vision of networked computers</li>
  <li>1969: first packet-switched network with four nodes</li>
  <li>early 70s: architectural concept for interconnection (TCP, IP)</li>
  <li>since 90s: commercialization</li>
  <li>since around 2005: software-defined networks</li>
  <li>today: ubiquituous, critical infrastructure</li>
</ul>

<p><strong>Internet of Things (Robots):</strong> Sensors collecting data about us and environment (Eyes and Ears); Processors, Storage and Cloud processing data (Brain);
Actuators affecting environment (Hands and Feet);</p>

<h3 id="router">Router</h3>
<h4 id="basic-functionalities">Basic Functionalities</h4>
<p><strong>Intermediate Systems</strong>: Forward data from input ports to output ports; Forwarding task of data path; may operate on different layers:</p>
<ul>
  <li><em>Layer 1</em> (Physical Layer, Bit√ºbertragungsschicht) - <em>Hubs</em> (schicken an alle Anschlussports)</li>
  <li><em>Layer 2</em> (Data Link Layer, Sicherungsschicht) - <em>Bridges</em> (entscheiden anhand MAC-Adressen)</li>
  <li><em>Layer 3</em> (Network Layer, Vermittlungsschicht) - <em>Routers</em> (entscheiden anhand IP-Adressen)</li>
</ul>

<p><strong>Routing</strong>: determines path that packet follows; part of control path; requires routing algorithms and protocols;</p>

<p><strong>Forwarding table</strong>: enth√§lt mindestens pro Eintrag Netzadresse/Subnetzmaske (bzw. Prefixl√§nge), next hop, Metrik (Gewichtung, Pr√§ferenz des Weges);
Informationen welcher Value im Paket, welchem Link entspricht;</p>

<p><strong>Router</strong>: main task: lookup in forwading table, forwart data from input to output ports; goals: forwarding in line speed (Geschw. des Links soll eingehalten werden), short queues
(da sonst hohe Latenz ‚Üí schlecht bei z.B. VoIP kommt es sonst zu Verz√∂gerungen), small tables (da sonst Speicher teuer)</p>

<p><strong>Forwarding</strong>: part of data path; Forwarding table part of control path;<br />
Incoming data ‚Üí  <em>IP-Processing</em>: check Headers of IP Packet (version number, valid header length, checksum); check TTL (decrement TTL); recalculate checksum)
‚Üí <em>Lookup</em> (determine output port for packet, Fragmentation (?), Handle IP options (?)) ‚Üí <em>Classification</em> (Priorization, differentiated treatment of packets) ‚Üí (Queue) ‚Üí Outgoing Data</p>

<h4 id="challenge-line-speed">Challenge: Line Speed</h4>
<p>bandwidth demand increases (32% 2015-2016); 250 Tbit/s in 2016 ‚Üí Link capacity has to increase<br />
memory is <strong>not</strong> keeping up with Moore‚Äôs law; network bandwidth doubles every 17-18 months; DRAM/CPU bandwidth doubles every 26-27 months;
Router needs to keep up with line-speed for <strong>all packet sizes</strong></p>

<p><em>Example:</em> 1 Gbit/s line-speed, 1500 byte packets: $ t_{packet} = \frac  {12000 bit}{10‚Åπ \frac {bit}{s}} = 12 \mu s $;
 higher requirements for smaller packets; forwarding decision is overhead for every single packet</p>

<p>Regarding TCP two types of segments:</p>
<ul>
  <li>TCP segments that transport data e.b. 1500 bytes (Ethernet)</li>
  <li>TCP that are purely acknowledgements (min. 40 byte)
‚Üí e.g only 3,2ns for 40 byte in a 100 Gbit/s environment<br />
Problem: Small packets are quite common, 50% of IPv4 packets smaller than 100 bytes</li>
</ul>

<p><strong>Router Types</strong>:</p>
<ul>
  <li><em>Core router:</em> used by service provider; large amound of aggregated traffic; high speed, reliability is essential (fast lookup, redundancy to increade reliability);
cost secondary issue (1-3 Mio. ‚Ç¨ per router)</li>
  <li><em>Enterprise router:</em> connect end systems in companies, universities,‚Ä¶; provide connectivity to many end systems; support VLANs, firewalls,‚Ä¶; low cost per post, large number
of ports, ease of maintenance</li>
  <li><em>Edge router (access router):</em> at <em>edge</em> of service provider; connectivity for customer (home, small business); support PPTP, IPsec, VPNs</li>
</ul>

<h4 id="forwarding-table-lookup">Forwarding Table Lookup</h4>
<p><strong>Prefix</strong>: Identifies block of addresses; continous blocks of addresses per output port good
‚Üí does not require a separate entry for each IP address (Scalability)</p>

<p><em>Ende Vorlesung vom 17.10.2018</em></p>

<p><strong>Longest Prefix Matching</strong>: Multiple prefixes matching in the forwarding table to given destination? Select most specific prefix
(highest number of matching bits) ‚Üí <em>longest prefix matching</em>; Challenge: Lookup in Line-Speed (can be long because TTL is decreased ‚Üí checksum recalculated),
 Different approaches in software:</p>

<p><strong>Efficient Data Structures for Longest Prefix Matching</strong><br />
Requirements: fast lookup; low memory; fast updates (route changes occur frequently, data structure should support¬†¬ª 100 updates/second)<br />
Variables: N = number of prefixes; W = length of prefix (W=32 for IPv4); k = length of stride</p>

<p><strong>Binary Trie</strong>: Trie = tree-based data structure to store and search prefix information; Idea: bits in prefix to tell algorithm what branch to take; (vgl. Abb. 02-27)</p>
<ul>
  <li><em>Lookup speed</em> $ O(W) $, maximum of one node per bit in prefix</li>
  <li><em>Memory requirement</em> $ O(N*W) $, prefixes stored as linked list starting from root, every prefix can have upt do W nodes</li>
  <li><em>Updates</em> $ O(W) $<br />
Lookup speed with memory access time $ 10ns $ for 100 byte packets $ 2,5 Gbit/s $ ‚Üí Optimization: Path Compression, Multibit Tries,‚Ä¶</li>
</ul>

<p><strong>Path Compression</strong>: one-child node waste memory ‚Üí nothing stored, not required for branch decision ‚Üí eliminate sequences ‚Üí path compression; additional information
of next examined index; (vgl. Abb. 02-31)</p>
<ul>
  <li><em>Lookup speed</em> $ O(W) $, with no one-child nodes, number of nodes to search = length of prefix</li>
  <li><em>Memory requirement</em> $ O(N) $, N entries for leaf nodes, N-1 for internal nodes ‚Üí max 2N-1 entries</li>
  <li><em>Updates</em> $ O(W) $</li>
</ul>

<p><strong>Multibit Trie</strong>: match multiple bits at same time; reduce number of memory accesses; fixed strides multibit tries (strides = number of bits)
have same strides on each level, different level can have different strides; Problem: prefixes do not always match with strides ‚Üí expand prefix to next available stride
(0* expands to 01* and 00*); choose prefix that is most specific; (vgl. Abb. 02-36)</p>
<ul>
  <li><em>Lookup speed</em> $ O(W/k) $</li>
  <li><em>Memory requirement</em> $ O(2^k NW/k) $, max path length W/k, path composed of one level subtrees with $ 2^k $</li>
  <li><em>Updates</em> $ O(W/k + 2^k ) $, search time $ O(W/k) $, modification $ 2^{k-1} $ entries</li>
</ul>

<p><strong>Hash Tables</strong>: goal: improve lookup speed ‚Üí $ O(1) $, BUT: longest prefix match only with hash table does <strong>not</strong> work; use additional hash table instead (stores result of trie lookup);
check for each IP packet if entry in hash table exists if not ‚Üí lookup; goof if addresses show ‚Äúlocality‚Äù characteristics</p>

<p><strong>Longest Prefix Matching in Hardware</strong><br />
Idea: Read information with single memory access, use destination IP as RAM address; waste of memory; required memor size grows expoentially with size of addresses;</p>

<p><strong>Content-Addressable Memory (CAM)</strong>: <em>RAM:</em> address ‚Üí data; <em>CAM:</em> data ‚Üí address (search all stored entries in single clock cycle,
very fast address lookups with address as search input); compare search input data with stored entries, priority encoder searches ‚Äúfirst‚Äù match</p>
<ul>
  <li><em>Binary CAM:</em> static lookups</li>
  <li><em>Ternary CAM:</em> with <em>Don‚Äôt Care</em> State; allows longest prefix matching, prefixes stored sorted by length; very fast lookups; BUT: hight energy demands
(parallelization, every core required for every lookup), high cost/ low density, requires strict ordering ‚Üí severe scalability limitations</li>
</ul>

<h4 id="router-architecture">Router Architecture</h4>
<p><strong>Generic Router Architecture</strong></p>
<ul>
  <li><em>Network Interfaces</em>: Access to attached networks; Layer 1, Layer 2 functionalities; basic functions of IP</li>
  <li><em>Routing Processor</em>: Routing protocol, management functionality</li>
  <li><em>Switch fabric</em>: ‚ÄúBackplane‚Äù, realizes internal forwarding<br />
Conflicting Design goals: high efficiency (line speed, low delay) vs. low cost; Blocking (e.g. packets arriving at the same time, going to same port)</li>
</ul>

<p><strong>Frage: TODO, irgendwas mit Blocking???</strong> Schicht 3. Schicht 2 nicht, da IP-Paket bereits aus Schicht 2 ‚Äúherausgeholt‚Äù; Indirekt aber Schicht 4, weil darin Schicht 3 Paket transportiert
<strong>Frage: Gibt es bei Verlust eine Sendewiederholung auf Schicht 4?</strong> Ja &amp; Nein. Abh√§ngig von Protokoll. TCP wird wiederholt, UDP nicht.</p>

<p><strong>Blocking</strong>: Packets are blocking each other, prevent blocking:</p>
<ul>
  <li><em>Overprovisioning:</em> circuits in switch fabric faster than input ports</li>
  <li><em>Buffering:</em> queue packets until resources available (network interface or switch fabric), possible buffer places (N input, output ports, storage M, speedup S, cycle time Z): <br />
 input buffer: FIFO at input; requirements S=1, Z= 1/2; Head-of-Line blocking (packet waiting but packet behind could be served); throughput N=2 ‚Üí 75%, N ‚Üí ‚àû ‚Üí 58,58%
 output buffer: FIFO at output; requirements: S=N, Z=1/(N+1); output buffer accepting packets N*S, input buffer at least one packet; throughput max 100%, usually 80-85%<br />
 distributed buffer: conflict resolution inside switch fabric, FIFO buffer per crosspoint; requirements: matrix structure, S=1, Z=1/2; no head-of-line blocking, higher memory than input/output <br />
 central: shared buffer for conflict resolution; Requirements: Z=1/2N, address memory for information of packets, control memory for parallelization</li>
  <li><em>Backpressure:</em> signal overlaod back to input ports, input ports can reduce load</li>
  <li><em>Parallel switch fabrics:</em> parallel transport of multiple packets to output ports, higher access sped required at output ports</li>
</ul>

<p><em>Ende Vorlesung vom 18.10.2018</em></p>

<p><strong>Switch Fabric</strong>: Basic Structures</p>
<ul>
  <li><em>Shared memory</em></li>
  <li><em>Bus/ring structure:</em> conflict-free access through time-division multiplexing, transmission capacity bus/ring (at least sum of all input ports),
easy support for multicast/broadcast, extensions limited, usually los number (approx. 16)</li>
  <li><em>Crossbar:</em> each input connected to each output, n inputs, n outputs n¬≤ crosspoints; partial parallel switching possible, multiple packets for same output
‚Üí Blocking ‚Üí Buffering required; especially efficient with same sized packets</li>
  <li><em>Multi-level switching networks:</em> switching states can set up multilevel connections (0 ‚Üí $O_1$, 1 ‚Üí $O_2$); Less wiring effort than crossbar, each input
connected with each output, not all connections at same time ‚Üí internal blocking possible</li>
</ul>

<h3 id="internet-routing">Internet Routing</h3>
<h4 id="basics">Basics</h4>
<p><strong>Control Path (Control Plane)</strong>: Routing protocols, exchange of routing messages for route calculation</p>

<p><strong>Data Path (Data Plane)</strong>: Lookup, Forwarding of IP packets (Layer 3)</p>

<p><strong>Routing Table</strong>: Generated by routing protocol; Entries: mapping of dest. IP prefixes to next hop (IP address);
optimized for particular routing algorithm; Implemented in software ‚Üí Performance not critical</p>

<p><strong>Forwarding Table</strong>: Used for packet forwarding; Entries:  Mapping of IP prefixes to outgoing ports (interface ID, MAC address);
optimized for rlongest prefix matching; Uses (partially) dedicated hardware ‚Üí Performance critical (Lookup in line speed)</p>

<blockquote>
  <p>Anmerkung aus Vorlesung: Lookup findet in Schicht 3 statt, da es sich um IP Pakete handelt; Routing Protokolle liegen √ºber SChicht</p>
</blockquote>

<p><strong>Routing metric (cost, weight)</strong>: used by router for routing decision; applied to link or overall path; e.g. Utilization, latency, data rate, number of hops</p>
<ul>
  <li><em>hop count</em>: distance between source and destination ‚Üí number of hops on the way, limited range: 1-15 (16 = infinity); schlechte Ma√ü, da Qualit√§t der hops
(= Geschwindigkeit der Links), nicht betrachtet</li>
</ul>

<p><strong>Routing policy</strong>: routing decision based on policies; defined by networrk operator/owner; e.g. prefered routes over specific neighbors</p>

<p><strong>Distributed Adaptive Routing</strong>: most commonly used; instance of protocol per router, exchange of routing information via routing messages; path
adaptions according to current network situation; <em>Path computation:</em> Network modeled as graph, Routers are nodes; Links are edges with metric</p>

<h4 id="autonomous-systems">Autonomous Systems</h4>
<p><strong>Autonomous System (AS)</strong>: internet divided into AS; indetification over unique number (Autonomous Systems Number - ASN: earlier 16 bit, now 32 bit); avg.
path length 3,83;  <br />
Properties: appears as single entity to the outside, uniform routing policy, typically uniform IGP; <br />
Advantages:</p>
<ul>
  <li><em>Operator autonomy:</em> separated administrative domains; increasing overhead with size of network</li>
  <li><em>Scalability of routing protocols:</em> Routing Protocol <em>inside</em> AS, Routing protocol <em>between</em> ASes; choice of IGP, Hiding internal structure</li>
</ul>

<p>IANA (Internet Assigned Numbers Authority) delegates allocation to RIR (Regional Internet Registries); around 45.000 issued ASNs</p>

<p>Classification of AS based on role:</p>
<ul>
  <li><em>Stub AS:</em> small organizations, mostly only regional, connected with exactly one provider, no transit traffic</li>
  <li><em>Multihomed AS:</em> large enterprises, connected to several providers (‚Üí Reliability), no transit traffic</li>
  <li><em>Transit AS:</em> Provider, often global scope,</li>
</ul>

<p>Classification based on ‚Äúeconomic position/influence‚Äù, no official mapping!</p>
<ul>
  <li><em>Tier 1:</em> (=Transit AS), do not buy transit, sell transit, peering with other Tier1s, e.g. Telekom</li>
  <li><em>Tier 2:</em> big national and interregional AS, downstream of Tier1 ASes, sell transit to other ASes, employ peering, e.g. Vodafone</li>
  <li><em>Tier 3:</em> small (regional) AS, downstream of Tier2 providers, do not sell to other ASes, sell to end customers, employ peering, e.g. Congstar</li>
</ul>

<p>How ensure mutual reachability? Cooperation among autonomous systems?</p>

<p><strong>Transit</strong>: Purchased connectivity, traffic exchange in both directions, only downstream AS must pay, Transit AS offers transit</p>
<ul>
  <li><em>Upstream:</em> provider (seller) of transit</li>
  <li><em>Downstream:</em> customer (buyer)</li>
</ul>

<p>Options for Connectivity: (Stub = Zugang)</p>
<ul>
  <li><em>Stub AS:</em> ein Zugang zum AS (und Rest des Internets), bei Ausfall keine Verbindung zum Internet</li>
  <li><em>Multihomed stub AS:</em> zwei Zug√§nge, Umstieg bei Linkausfall</li>
  <li><em>Multihomed AS:</em> zwei Transit Verbindungen</li>
</ul>

<p><strong>Peering</strong>: Direct connection, typically between ASes of same tier;</p>
<ul>
  <li><em>Private Peering:</em> no costs for traffic exchange; mostly only data traffic between privately peered AS, no transit in other ASes
‚Üí Connectivity is not achieved; Advantages: benefits for both ASes (save transit costs), shorter data paths; Problems: direct connection complicated
(geographical distance), Full mesh of n ASes more than 1 billion connections!</li>
  <li><em>Public Peering:</em> through Internet Exchange Points (IXP, central public authority for interconnection): neutral traffic forwarding on layer 2, monthly
fixed charges per port ‚Üí expensive infrastructure, Different Peering policies:
    <ul>
      <li>Open</li>
      <li>Selective: specific terms and conditions</li>
      <li>Restrictive: no new peering relationships</li>
      <li>No Peering</li>
    </ul>
  </li>
</ul>

<p><strong>Content Delivery Provider</strong>: Goal: fast content delivery ‚Üí locations close to Tier1 peering points</p>

<p><strong>Content delivery networt (CDN)</strong>: connected over own routers, world wide network with own AS number, points of presence (PoP) spread over world
(access and core routers, customer connection through access router), load balancing at access router, low latencies</p>

<p><strong>Routing Protocols</strong>:</p>
<ul>
  <li><em>Interior Gateway Protocol (IGP):</em> Routing inside an autonomous system, not visible to the outsides, different IGPs possible, metric-based
    <ul>
      <li><em>Routing Information Protocol (RIP):</em> commonly used, distance vector algorithm</li>
      <li><em>Open Shortes Path First (OSPF):</em> commonly used, link state algorithm</li>
      <li><em>Intra-Domain Intermediate System to Intermediate System Routing Protocol (IS-IS):</em> ISO Standard, link state algorithm</li>
      <li><em>Enhanced Interior Gateway Routing Protocol (EIGRP):</em> CISCO, link state algorithm, based on RIP</li>
    </ul>
  </li>
  <li><em>Exterior Gateway Protocol (EGP):</em> Routing between autonomous systems; EGPs m√ºssen einheitlich sein; policy-based; im Einsatz: <em>Border Gateway Protocol</em></li>
</ul>

<h4 id="roting-information-protocol-rip">Roting Information Protocol (RIP)</h4>
<p><strong>Routing Information Protocol (RIP)</strong>: IGP, one of first routing protocols, very simple, little configuration; oberhalb von IP; application process
implements RIP, manages forwarding table; RIP sent over UDP ‚Üí <em>not reliable</em><br />
<em>Routing Messages:</em> exchange messages over UDP</p>
<ul>
  <li><em>Request Message:</em> complete routing table (partly)</li>
  <li><em>Response Message:</em> response to query,
    <ul>
      <li>Regular Routing update: broadcasted every 30sec, not synchronized, entire routing table to neighbors, no refresh for at least 180s
  ‚Üí in case UDP messages are lost, retry, hop count 16 ‚Üí route is invalidated;</li>
      <li>Triggered Update: because of route change, not complete table; rate limitation to reduce load, randomized between 1 and 5 seconds, changes during period
  accumulated and sent in one message</li>
    </ul>
  </li>
</ul>

<h4 id="ospf-open-shortest-path-first">OSPF: Open Shortest Path First</h4>
<p><strong>Open Shortest Path First (OSPF)</strong>: Interor Gateway Protocl, based on Link State, each router
needs to learn complete topology of network (nodes, links with costs), each router computes
shortes path (dijkstra), every router must have identical knowledge ‚Üí otherwise inconsistent
paths; OSPF on top of IP ‚Üí unreliable communication</p>

<p><strong>Routing metric:</strong> each link associated with link costs, configured value, $Cost =
\frac{ReferenceBandwidth}{InterfaceBandwidth}, ReferenceBandwidth = 100Mbit/s (default)</p>

<p><strong>Link State Advertisement(LSA):</strong> with information about neighbors and links; flood LSA to all
interfaces ‚Üí router must have identival copy of LSA; Lifetime: MaxAge = 1 hour, LSRefreshTime = 30 min; if nothing changes, nothing needs to be reported
‚Üí keep quiet, LSAs refreshed every 30mins, otherwise communication only needed in case of changes; min time between two consecutive LSAs 5 secs <br />
Structure:</p>
<ul>
  <li><em>Header:</em>
    <ul>
      <li>LS Age, Options, LS Type (Hello, link state advertisement, acknowledgement)</li>
      <li>Version: OSPF Version: 2 for IPv$, 3 for IPv6</li>
      <li>Type: Hello, link state advertisement, acknowledgement</li>
      <li>RouterID: identifier of router that originated packet</li>
      <li>AreaID</li>
      <li>AUType and Authentication: option authentication, verifies that sending router belongs to same network</li>
      <li>LSAs: if tye is LSA</li>
    </ul>
  </li>
  <li><em>Body:</em> variable
    <ul>
      <li>(Advertising Router Flags)</li>
      <li>#Links</li>
      <li>Link ID</li>
      <li>Link Data: type dependent</li>
      <li>Type, #ToS, Metric</li>
      <li>ToS, 0, ToS Metric</li>
    </ul>
  </li>
</ul>

<p>Flooding: Goal: Link State databases must have identical content ‚Üí need to be synchronized, following actions needed:</p>
<ul>
  <li>ensure each LSA is received by every router ‚Üí reliable flooding</li>
  <li>ensure each router consistently store (if LSA is newer ‚Üí sequence number higher) or discard each LSA ‚Üí fully deterministic comparison rules</li>
  <li>ensure that expired LSAs are pruned from link state databases</li>
</ul>

<p><strong>Link State Database:</strong> LSAs from all routers in network stored; for topology graph and routing table</p>

<p><strong>Hello Protocol:</strong> establish, maintain logical adjacencies, ensure bi-direction communication
‚Üí determines identity and liveliness of neighbors</p>

<p><em>Workflow:</em> Router sends hello messages (own routerID, routerID of neighbors, dest. IP of message) periodically</p>

<p><strong>Areas</strong>: AS grow rather large, LSA flooding and route computation overhead ‚Üí do not scale; Concept: Divide AS into <em>areas</em>, Link state algorithms only within area, areas exchange
summary of information, typical size in area: less than 100 router ‚Üí only router within area have same link state databases; Area 0 = backbone of AS, other areas directly connected to AS
via area border router, Inter-Area Forwarding through backbone area</p>

<p><strong>Area Border Router (ABR)</strong>: connected to both areas, instance of OSPF for each area, generate summary LSAs, Handling summary of LSAs</p>

<p>On OSPF every router is pre-configured with: routerID (e.g. smallest IP address of its interfaces), Per-interface parameters (interface IP address, mask; interface output cost (metric))</p>

<p><strong>RIP vs. OSPF</strong></p>

<table>
  <thead>
    <tr>
      <th>¬†</th>
      <th>RIP</th>
      <th>OSPF</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Algorithm</strong></td>
      <td>distance vector (limited metric selection and size, max path length of 15 hops</td>
      <td>links state</td>
    </tr>
    <tr>
      <td><strong>Messages</strong></td>
      <td>periodic updates every 30secs, even without changes</td>
      <td>updates only on change</td>
    </tr>
    <tr>
      <td><strong>Resources</strong></td>
      <td>easier, less resources</td>
      <td>more complicate, more resources</td>
    </tr>
    <tr>
      <td><strong>Usage</strong></td>
      <td>somethimes in small networks</td>
      <td>standard in large ASes, large networks divided into areas</td>
    </tr>
  </tbody>
</table>

<p><strong>ARPANET Routing Metric</strong>: early routing metric versions based on delay; Problems: queue length can change significantly, metric may lead to routing oscillations, bandwidth not
considered<br />
Measuring Delay: $ t_v = (T_{out} - T_{in}) + t_a + t_s$ ; $T_{in}$: packet receiving time, $T_{}out $: sending first bit of packet, $t_a$: Ausbreitungsverz√∂gerung (Kabel√ºbertragungszeit),
$t_s$ = Sendezeit (Zeit um Paket komplett zu senden)<br />
Problem: measured delay good indicator <em>after</em> rerouting; experienced delay ony godd in case of low load  ‚Üí route oscillations, low network utilization<br />
Routing Oscillation: hin und her zwischen Link A und Link B<br />
Improvement: during heacy load better take good paths than optimal paths: $ œÑ = \frac{k}{C(1-œÅ)} ‚áí œÅ = 1 - \frac{k}{CœÑ} $ and smoothed utilization value:
$U(n + 1) = 0,5 ‚àó œÅ(n + 1) + 0,5 ‚àó U(n)$ ‚Üí damps oscillations
with: $œÑ$: average delay, $œÅ$: measured utilization, $C$: link speed, $k$: average packet size, $U$: smoothed utilization</p>

<p><strong>Equal Cost Multipath (ECMP)</strong>: multiple paths with lowest cost may exist; ECMP splits traffic <em>equally</em> between paths with lowest cost; allows load balancing; OSPF supports ECMP</p>

<p><strong>Traffic Engineering</strong>: Goal: Performance optimization for networks; determine proper link weights (lieber 80% als 100% auf einem Link).</p>

<ul>
  <li>Usage of all resources</li>
  <li>Performance requirements</li>
  <li>Medium term goal: handle peaks of a usual day</li>
</ul>

<p>Traffic engineering is monitoring and managing the existent resources and it is
not about adding new routers etc. Changes of the topology are made via the
routing protocol (OSPF supports this).</p>

<p>Traffic engineering is not new. Cellphone line providers already had such a
monitoring and routing management.</p>

<p><strong>Exterior Gateway Protocol (EGP):</strong> large networks in AS usually only have
information about themselves, number of entries in routing table and amount of
exchanged routing information does not
scale, per AS at least one intermediate system with interface to another AS<br />
 Advantages:</p>
<ul>
  <li><em>Scalability:</em> size of routing table depends on AS size, changes in routing tables only propagated within AS</li>
  <li><em>Autonomy:</em> routing can be controlled within own network, not the same routing protocols within AS necessary</li>
</ul>

<p><strong>Border Gateway Protocol (BGP)</strong>: most important EGP, basis of today‚Äôs internet routing, worldwide usage;
Path Vector Protocol: Extension of distance vector approach, routing metric = paths (guarantee no loop exist),
routing/paths are based on policies (e.g. cheapest path, not over AS xyz),
routing not pre-determined; through smart address assignment, address ranges are summarized by single prefix ‚Üí improves scalability</p>

<p>The protocol has not been changed significantly since the first days in
comparison to changes made to TCP.</p>

<p><em>Structure:</em></p>

<ul>
  <li><em>External BGP (EBGP):</em> between routers of <em>neighboring</em> ASs; announcement, forwarding of path information; no internal AS details exchanged</li>
  <li><em>Internal BGP (IBGP):</em> between BGP routers within AS; synchronization of BGP routers; Transit AS establish transit routes</li>
</ul>

<p>BGP calculates routes to prefixes from <strong>other</strong> ASs, IGP of local AS broadcasts routes to destinations <strong>within</strong> AS<br />
Possible approaches for routing with BGP and IGP:</p>
<ul>
  <li>IGP distributes default routes: unknown address/prefix packets to BGP router by shortest path</li>
  <li>Publication of external routes via IGP: BGP router responsible for specific external prefixes</li>
  <li>IGP router also speaks BGP (IBGP)<br />
Sessions: Point-to-Point (via TCP between directly connected routers = neighbors, peers); hen-eg-problem, how to establish TCP connection?
‚Üí IBGP: IGP of AS can be used <br />
‚Üí EBGP: usually direct physical connection (no routing required), manual config</li>
</ul>

<p><em>IBGP Connections:</em></p>
<ul>
  <li>Simple case: BGP routers fully meshed/directly connected, but then sessions must be kept alive, bad scalability</li>
  <li>Alternative 1: concentrate IBGP traffic in a single router = route reflector, has to maintain sessions, forwards messages, in practice more than one reflector ‚Üí reliabilty</li>
  <li>Alternative 2: form hierarchies from sub ASes (AS confederations), implement more complex policies, confederation appears as a single AS</li>
</ul>

<p><em>BGP Messages:</em></p>
<ul>
  <li>OPEN: establish BGP connection to peer, TCP connection must alread exists!, authentication</li>
  <li>UPDATE: announcement of new / withdrawal of outdated path; only sent if new/better paths available. Theoretically there is an
aggregation function but due to the splitting of IP regions, it can not be used a lot.</li>
  <li>KEEPALIVE: keeps connection alive in absence of update messages, acknowledgement for OPEN request</li>
  <li>NOTIFICATION: error message / tear down of BGP connection</li>
</ul>

<p><em>BGP Routing:</em> no predefined routing metric ‚Üí policies ‚Üí Routing Information Base (RIB): DB for received, dispatched routing information</p>
<ul>
  <li>Incoming updates: Adj-RIB-In (Adjacency RIB Incoming), exists per peer, stores information received from peer</li>
  <li>Input Policy Engine: Filtering of information according to rules</li>
  <li>Decision-making Process: Selection of best route</li>
  <li>Loc-RIB: Local RIB, Routing Informaiton Base, actual routing table, only preferred routes, routes form <em>Forwarding Information Base (FIB)</em></li>
  <li>Output Policy Engine: Filtering of information according to defined rules</li>
  <li>Outgoing updates: Adj-RIB-OUT (Adjacency RIB Outgoing), exists per peer, contains routes published to peer</li>
</ul>

<p><em>BGP Challenges:</em> maintaining scalability ( growth of routing tables, increasing dynamics), increased demands on internet, security problems</p>

<p><strong>Route Flap Damping</strong>: Routes in routing table change more frequently ‚Üí temporarily suppressing changes of unstable routes; penalty per update, penalty drops exponentially over time, can lead
to connectivity loss!</p>

<p><strong>Security Extensions for BGP</strong>: to secure route information, authentication and authorization of senders, integrity protection and encryption, secured routing through IPSec and TCP mit MD5</p>
<ul>
  <li><em>soBGP (secure origin BGP):</em> from Cisco</li>
  <li><em>S-BGP (secure BGP):</em> from BBN-Technologies</li>
</ul>

<p><strong>Cleaning Center</strong>: Redirect traffic to separate DDoS attack traffic and legitimate traffic, legitimate traffic routed back to AS ‚Üí BUT: good position for ‚Äúman in the middle‚Äù attacker</p>

<h3 id="label-switching">Label Switching</h3>
<h4 id="motivation">Motivation</h4>
<p>Issures related to IP based routing: Lookup complex, Shortest path routing, packet based</p>

<h4 id="flows">Flows</h4>
<p><strong>Flows</strong>: A flow is a sequence of packets traversing a network that share a set of header field values; Ip routing is special case flow based forwarding, concept also applicable to Ethernet
switching</p>
<ul>
  <li><em>Micro-flows:</em> single ‚Äúconnection‚Äù, fine grained control, high number of flows possible</li>
  <li><em>Macro-flows:</em> higher level of aggregation, several ‚Äúconnections‚Äù, lower number of flows</li>
</ul>

<p><strong>Flow based forwarding</strong>: fundamental concept, indepentent of layers (can also span multiple layers), incorporates classic routing/forwarding concepts</p>

<h4 id="label-switching-1">Label Switching</h4>
<p><strong>Types of Communication Networks:</strong></p>
<ul>
  <li><em>Packet Switching:</em> packets forwarded independent of each other, meta data required, expensive forwarding decision (e.g. IP)</li>
  <li><em>Circuit Switching:</em> connection with fixed resource reservations, no meta data within data stream required (e.g. ISDN)</li>
  <li><em>Virtual Switching:</em> connections without fixed resource reservation, packet efficiently forwarded on same path, inexpensive label-based
forwarding decision (e.g. MPLS)</li>
</ul>

<blockquote>
  <p>Label Switching: communication network, switched, packet-switched, connection-oriented (e.g. ATM, MPLS) ‚Üí Label Switching
is combination of packet switching (packets forwarded individually, packets include metadata) and circiut switching (paths
for flows through network, simple forwarding)</p>
</blockquote>

<p><strong>Implementation of Label Switching</strong>: Switching at Layer 2 (instead of routing at layer 3), Labels (local Identification),
Virtual circiuts (Sequence of labels)</p>

<p><strong>Label</strong>: Short unstructured identification of fixed length (no Layer 3 information, unique, only locally at correcsponding
switch, label swapping (mapping input - output label)), Virtual circuit (identified through sequence of labels at path)<br />
<em>Tranport:</em> Label must be transported within packet<br />
<em>Structure:</em> Layer 2 (Ethernet Head) | Label | Layer 3 (IP-Datagram) | Data</p>

<p><strong>Label Switching Domain</strong>:</p>
<ul>
  <li><em>Edge Devices:</em> at border of domain; add/remove labels, map flow to forwarding class, access control</li>
  <li><em>Switching Device:</em> within domain; forwar packets based on label information, label swapping</li>
</ul>

<p><strong>Multiprotocol Label Switching (MPLS)</strong>: based on label switching, data plane optimization</p>
<ul>
  <li>Fast Forwarding due to reduced amount of packet processing</li>
  <li>QoS support (guarantees on latency, capacity)</li>
  <li>Traffic engineering (load balancing)</li>
  <li>Virtual private networks (isolated traffic)</li>
  <li>mulitple networks support <br />
‚Üí good Acceptance: on top of IP, separation between forwarding (label switching) and control (manipulation of label binding),
not limited on IP, support metrics, scales<br />
<em>Components:</em></li>
  <li>Label-switching router (LSR): MPLS-capable IP router, can forward packets based on IP prefixes and MPLS labels</li>
  <li>Labeld edge router (LER): Router at edge of MPLS domain (LSR with non-MPLS capable neighbor is LER), classifies packets that enter MPLS
domain</li>
  <li>MPLS-Node: MPLS-capable intermediate system<br />
<em>Label:</em> Encapsulation between headers of Layer 2 and 3, Structure:</li>
  <li>Label 20 bit</li>
  <li>Exp: Bit for experimental usage, 3 bit</li>
  <li>S: Stack bit, 1 bit</li>
  <li>TTL: Time-to-live, 8 bit</li>
</ul>

<p><strong>Forwarding Equivalence Class (FEC)</strong>: class of packets, that should be trated equally (same path, same QoS), basis for
label assignment, MPLS-specific, synonym to <em>flow</em>; FEC mapping 5 Tupels: ToS, IP Source Address, IP Destination Address,
 Source port, Destination port ‚Üí LSP/label
<em>Granularity</em>:</p>
<ul>
  <li>coarse-grained: important for quick forwarding and scalability</li>
  <li>fine-grained: important for differentiated treatment of packets/flows</li>
</ul>

<p><strong>Label Switched Path (LSP)</strong>: Virtual connection, no resources reserved<br />
<em>Communication</em>: define FEC, distribute labels, establish LSP</p>

<p><strong>Label Switched Router (LSR)</strong>:</p>
<ul>
  <li><em>Downstream LSR:</em> in direction of data flow</li>
  <li><em>Upstream LSR:</em> against direction of data flow</li>
</ul>

<p><strong>Types of Label Distribution:</strong></p>
<ul>
  <li><em>Unsolicited downstram:</em> generates label bindings as soon as it is ready to forward MPLS packets of the respective FEC</li>
  <li><em>Downstram on demand:</em> Downstream router generates label binding on demand</li>
  <li><em>Originally:</em> Label distribution protocol defined along with MPLS</li>
  <li><em>De-facto:</em> RSVP-TE is used mostly</li>
</ul>

<p><strong>Resource ReserVation Protocol (RSVP)</strong>: bandwith reservation for end-to-end data streams, soft state principle (establish
session an signal that it is still alive), Scalablity issues!</p>
<ul>
  <li>Path message: sender ‚Üí receiver, find path, each hop recorded</li>
  <li>Resv message: receiver ‚Üí sender, bandwidth reservation</li>
</ul>

<p><strong>Resource ReserVation Protocol - Traffic Engineering (RSVP-TE)</strong>: extension to RSVP, additional functionalities e.g. fast
reroute</p>

<p><strong>Virtual Private Networks (VPN)</strong>: MPLS enables VPNs; here: renting guaranteed transmission capacities from a network provider<br />
<em>VPNs with Label Switching:</em> outer label identifies path to LER, inner label identifies VPN instance</p>

<p><strong>Traffic Engineering:</strong> extension of Link State routing protocols (additional information needed, all nodes have global view
on network)</p>

<h3 id="software-defined-networks-sdn">Software Defined Networks (SDN)</h3>
<blockquote>
  <p><strong>Traditional IP Networks:</strong> every router control and data plane functions, control is decentralized ‚Üí Limitations! ‚Üí SDNs
increase flexibilty and decrease dependencies on hardware</p>
</blockquote>

<h4 id="basics-and-architecture">Basics and Architecture</h4>
<p><strong>Characteristics of Software-Defined Networks</strong>: Separation of control and data plane; control functionalities ‚Üí SDN controller,
Data plane ‚Üí simple packet processors (SDN switches), control plane has global network view (knows all switches, network topology),
network ist software-programmable (network applications), processing based on flows</p>

<p><strong>Basic Operation in SDNs</strong>:</p>
<ul>
  <li>Control functionality, SDN controller (e.g. Routing including routing table), SDN controller programs entries in flow table (protocol required!)</li>
  <li>Forwarding table on SDN switch (name here: <em>flow table</em>), for every incoming packet in SDN switch ‚Üí suited entry in flow table needs to be
determined</li>
</ul>

<p><strong>Flows</strong>: Identified through match fields (e-g- IP address, port number)</p>

<p><strong>Flow table</strong>: contains match fields, actions, ‚Ä¶; matches appropriate flow table entry, actions are applied to all packets that match</p>

<p><strong>Flow rule</strong>: Decision of controller, described in form of match fields, actions, switches</p>

<p><strong>Flow Programming:</strong></p>
<ul>
  <li><em>Proactive flow programming:</em> rules programmed before first packet of flow arrives, no additional delay, loss og controller
connectivity does not disrupt traffic</li>
  <li><em>Reactive flow programming:</em> rules programmed in reaction to receipt of first packet, setup time per flow, high overhead for
short lived flows, new flows cannot be installed if controller connectivity is lost</li>
</ul>

<p><strong>Important Interactions</strong>:</p>
<ul>
  <li>Flow rule send to switch ‚Üí new flow table entry (reactive and proactive)</li>
  <li>Packet forwarded to controller (primarily reactive)</li>
  <li>Packet re-injected to switch (primarily reactive)</li>
</ul>

<p><strong>SDN Architecture</strong>:
Planes:</p>
<ul>
  <li><em>Application Plane:</em> Network apps perform network control and management tasks, interacts via <em>northbound API</em> with control plane</li>
  <li><em>Control Plane:</em> control tasks outsourced from data plane to logically centralized control plane, more complex tasks delegated to application plane</li>
  <li><em>Data Plane:</em> packet forwarding/processing, SDN switches are simple, interacts via <em>southbound API</em> with control plane
Interfaces:</li>
  <li><em>Northbound API:</em> controller ‚Üî network apps (exposes control plane functions to apps, abstract from details, apps can operate on consistent network view)</li>
  <li><em>Southbound API:</em> controller ‚Üî switches (exposes data plane functions to controller, abstracts from hardware details)</li>
  <li><em>Westbound API:</em> controller ‚Üî controller (synchronization of network state information)</li>
  <li><em>Eastbound API:</em> interface ‚Üí legacy infrastructures<br />
‚Üí No widely accepted standard for north/westbound interfaces</li>
</ul>

<h4 id="sdn-workflow-in-practice">SDN Workflow in Practice</h4>
<p><strong>SDN programming primitives:</strong> to assist with creating app, important areas:</p>
<ol>
  <li><em>to create, install flow rules:</em> app that implements flow rule decisions, programs flow table entries into switch
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">...</span>

<span class="c1">// entry point to implement custom logic</span>
<span class="c1">// called when control connection established</span>
<span class="c1">// reference to switch as parameter</span>
<span class="nx">onConnect</span><span class="p">(</span><span class="k">switch</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">switch</span> <span class="o">==</span> <span class="nx">S1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">r</span> <span class="o">=</span> <span class="nx">Rule</span><span class="p">();</span> <span class="c1">//data structure holding single flow rule, can be modified with function calls</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">MATCH</span><span class="p">(</span><span class="dl">'</span><span class="s1">IP_DST</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">1.2.3.4</span><span class="dl">'</span><span class="p">);</span> <span class="c1">//select packet based on certain criteria ‚Üí here: IP address</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">ACTION</span><span class="p">(</span><span class="dl">'</span><span class="s1">OUTPUT</span><span class="dl">'</span><span class="err">‚Äö</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//specify what happens to matched packets in switch, e.g. m.ACTION(OUTPUT, 7),  m.ACTION(DROP)</span>
        <span class="nx">send_rule</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="k">switch</span><span class="p">);</span> <span class="c1">//install flow rule in switch, creates new flow table entry or overwrites existing one</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>‚Üí creates a new flow rule, sends flow rule to S1
<em>Priorities:</em> if flow rules are overlapped
        - no overlap: all packets can only be matched by one rule
        - overlap: at least one packet could be matched by more than one rule<br />
‚Üí need to define priorities: default priority=1, higher priorities overwrite rules with lower priority</p>
  </li>
  <li><em>react to data plane events:</em> controller API provide callbacks:
    <ul>
      <li>to react to control events (e.g onConnect(switch))</li>
      <li>to deal with packets sent to controller (e.g. onPacketIn(packet, switch, inport)): called if packet was forwarded via <em>r.ACTION(CONTROLLER)</em></li>
    </ul>
  </li>
  <li><em>inject individual packets:</em> handle individual packets (forward a packets, perform topology detection, active monitoring, answer ARP requests)
    <ul>
      <li>injects single packet (only!) into switch (e.g. send_packet(packet, switch, [rule])), if rule parameter present it
 does not create a new flow table entry</li>
      <li>handle injection:</li>
    </ul>
    <ol>
      <li>inject and process packet in flow table (no usage of optional rule parameter), rule must be installed before injection, otherwise cycle</li>
      <li>inject and process packet with custom rule (usage of optional rule parameter), actions attached to packet, rule only used for this packet, flow
table remains unchanged; ‚Üí Advantages: more efficient (not creating flow table entries every time), Inconsistencies (if packets matching a rule, while
network is in inconsistent state = renewing a rule)</li>
    </ol>
  </li>
</ol>

<p><strong>Multiple Flow Tables</strong>: SDN support more than one flow table, expensive in hardware, specify table with <em>r.table(x)</em><br />
<em>Benefits:</em> used to isolate flow rules from apps, logical separation between tasks</p>

<p><strong>Self-Learning Switches</strong>: Goal: hinter welchem Port liegt welche IP-Adresse ‚Üí kein Fluten notwendig</p>
<ol>
  <li>Switch receives packet and does not know destination address: floods packets, learn location</li>
  <li>Switch reveices packet and know destination address: forwards packet<br />
‚Üí possible with SDNs: Leaning Switch App</li>
</ol>

<p><strong>Learning Switch Example</strong>:</p>
<ul>
  <li><em>Naive Approach:</em> send all packets to controller, controller creates rules based on INPORT and MAC ADDRESS,
unknown des. address ‚Üí flooding; Problem: Controller has no chance to learn ports</li>
  <li><em>Version 2 (with delayed rule installation):</em> delay rule installation until dest. address was learned, Problem: still not learning enough</li>
  <li><em>Version 3 (with more specific matching):</em> only matching dest. address not enought, use more specific matches, ensures all end systems can be learned
Problem: functional perspective good, but: not scalable/usable ‚Üí amount of flow table entries can be large</li>
  <li><em>Version 4 (with multiple flow tables):</em> separate flow tables for learning and forwarding, 2*N rules for N end systems</li>
</ul>

<h4 id="open-flow">Open Flow</h4>
<p><strong>OpenFlow</strong>: southbound interface (interaction between controller and switches, logical architecture for SDN switches)</p>
<ul>
  <li><em>Ports:</em> represent logical forwarding targets, can be selected by output action, physical ports ‚Üí hardware interfaces<br />
Reserved Ports:
    <ul>
      <li>ALL: flooding</li>
      <li>IN_PORT: send packet back</li>
      <li>CONTROLLER: send packet to controller</li>
      <li>NORMAL: forwarding to vendor-specific switch implementation<br />
Logical Ports:</li>
      <li>link aggregation: multiple interfaces combined to single logical port</li>
      <li>transparent tunneling: traffic forwarded via intermediate switches</li>
    </ul>
  </li>
  <li><em>Flow Table:</em>
    <ul>
      <li>Match fields ‚Üí mandatory</li>
      <li>Priority ‚Üí mandatory</li>
      <li>Actions ‚Üí mandatory</li>
      <li>Counters: number of processed packets</li>
      <li>Timeouts: max lifetime of flow, automatic flow removal</li>
      <li>Cookies: marker value set by SDN controller</li>
      <li>Flags: indicate how flow is managed, notifies controller if flow is automatically removed</li>
    </ul>
  </li>
  <li><em>Group Table:</em> definiert Rules f√ºr jede Gruppe von Flows, nicht f√ºr jeden Flow einzeln, group entries invoked from other tables via group
actions, referenced by unique group identifier, flow table entries can perform group actions during ingress processing,
effect of group processing depends on group type and action buckets
    <ul>
      <li>Action Buckets: per group zero or more action buckets, contains set of actions to execute</li>
      <li>Group Types:
        <ul>
          <li>all: alle buckets in Gruppe w√§hlen</li>
          <li>indirect: einziges bucket in gruppe</li>
          <li>select: ein bucket aus vielen der Gruppe w√§hlen</li>
          <li>fast failover: erstes bucket, das mit aktivem port verkn√ºpft ist</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><em>Pipeline Processing:</em> multiple flow table chained to flow table pipeline, flow tables numbered in order, traversed by packets, processing
starts at flow table 0, only forward traversal, actions accumulated in action set,
    <ul>
      <li>ingress processing: packet processing starts with ingress processing, start at flow table 0, initial action set empty</li>
      <li>egress processing</li>
    </ul>
  </li>
</ul>

<h4 id="power-of-abstraction">Power of Abstraction</h4>
<blockquote>
  <p>Abstraction is major reason for success in OS ‚Üí similar goals for networking domain</p>
</blockquote>

<p>Controller can provide different abstractions to network apps, Apps should not deal with low level/unnecessary details, abstract view
on network, OpenFlow is no suitable for SDN Abstraction</p>

<p><strong>FlowVisor</strong>: Network slicing (simple form of virtualization), individual users get ‚Äúown‚Äù network slice</p>

<h4 id="sdn-challenges">SDN Challenges</h4>
<p><strong>Controller Connectivity</strong>: SDN required connectivity between controller ans switches, otherwise no exchange of control messages,
no updates in flow tables, no control of the network; Connectivity Modes:</p>
<ul>
  <li><em>Out-of-band:</em> extra Kabel; dedicated (physical) control channel for messages between controller and switch</li>
  <li><em>In-band:</em> kein extra Kabel; control message use same channel as ‚Äúnormal‚Äù traffic, multiple apps can configure switch ‚Üí both apps
can disable ports ‚Üí no controller connectivity anymore</li>
</ul>

<p><strong>Scalability</strong>: requires powerful controllers, size/load of networks can easily overload control plane, important parameters:
number of remotely controlled switches, hosts/flows, messages</p>

<p><strong>Distributed Controllers</strong>: reasons for distributed controllers: Scalability, Responsibilities, Reliability, Incremental
deployment; BUT: controller must have consistent knowledge ‚Üí westbound interface to communicate</p>

<p><strong>CAP Theorem</strong>: multiple controller cause same problems as in distributed system ‚Üí CAP Theorem</p>
<ul>
  <li><strong>C</strong>onsistency: system responds identically to request no matter which node receives request (or not at all)</li>
  <li><strong>A</strong>vailability: system always responds to request</li>
  <li><strong>P</strong>artition tolerance: system continues to function even when messages are lost<br />
‚Üí inherentes Problem, nicht m√∂glich alle drei Punkte gleichzeitig zu erf√ºllen, nur zwei gleichzeitig m√∂glich</li>
</ul>

<p><strong>Flow Table Capacity</strong>: SDN needs a lot more than 20.000 rules, fast processing requires TCAM (current hardware max. 20.000 entries) ‚Üí
workarounds like caching, flow aggregation, optimized distribution</p>

<p><strong>Flow Setup Latency</strong>: setting a new flow requires that a rule is generated at SDN controller and installed at switch ‚Üí directly affects
control latency of network ‚Üí clever placement of controller</p>

<p><em>Ende der Vorlesung vom 21.11.2018</em></p>

<h4 id="tools">Tools</h4>
<p><strong>OpenDaylight</strong>: SDN Controller, Java-based, focus on network programmability, OpenDaylight Architecture: zwischen UI, Network apps und
Controller</p>

<p><strong>Virtual Switches</strong>: core component in data centers #VMs¬†¬ª #physical servers, #Virtual Ports¬†¬ª #physical ports ‚Üí one
virtual switch per physical server ‚Üí ‚Äúvirtual‚Äù Top-of-Rack switches, e.b. Open vSwitch</p>

<h3 id="network-function-virtualization">Network Function Virtualization</h3>
<h4 id="network-functions">Network Functions</h4>
<p><strong>Middlebox</strong>: device on data path, between source and destination end system, performs functions other than normal, standard functions
of IP router</p>

<p><strong>Network Function</strong>: functionality of middlebox, executed on data path</p>

<p><strong>Network Address Translation (NAT)</strong>: connects a realm with pricate addresses to external realm with globally unique addresses,
Problem: private address not usable for routing in internet ‚Üí exchange globally unique and private address when packets traverse network boundaries</p>

<p><strong>Firewall</strong>: monitors and controls incoming and outgoing traffic<br />
<em>Packet inspection</em>:</p>
<ul>
  <li>Shallow packet inspection: decisions based on header fields only (bis Layer 4)</li>
  <li>Deep packet inspection: inspect content of higher layer protocols (e.g malware detection)</li>
</ul>

<p><em>Processing:</em></p>
<ul>
  <li>Stateless: every packet inspected independently of other packets</li>
  <li>Stateful: keeps state between packets</li>
</ul>

<p><strong>Web Cache</strong>: provides additional storage on data path, temporarily caches content provided by remote server ‚Üíreduces time for content
delivery ‚Üí CDNs capitalize on well-placed caches ‚Üí multiple middleboxes at different locations in network ‚Üí Problems with middleboxes:
fast, but inflexible, closed source, static wiring, ‚Ä¶</p>

<p><strong>Network Function Virtualization (NFV)</strong>: ideas of cloud computing (implement network functions in software, use virtualization technology);
Traditional middlebox with caching functionality ‚Üí (Softwarization) ‚Üí Caching functionality implemented in software ‚Üí (Virtualization) ‚Üí
Executed on hardware<br />
<em>Benefits</em>:</p>
<ul>
  <li>Resource sharing</li>
  <li>Agility and flexibility</li>
  <li>Rapid deployment</li>
  <li>Reduced costs</li>
</ul>

<p><em>Main Building Blocks:</em></p>
<ul>
  <li>Virtualized Network Functions (VNFs): network functions provided in sofware</li>
  <li>NFV Management and Orchestration (MANO): Lifecycle management of VNFs and network services</li>
  <li>NFV Infrastructure (NFVI): Provides hardware, software and network resources for VNFs, can contain multiple Points of Presence, SDN used
to transparently reroute flows to PoPs</li>
</ul>

<p><strong>Network Service</strong>: Network services combine multiple network functions</p>

<p><strong>Point of Presence (PoP)</strong>: small data centers, located at different points in infrastructure</p>

<h4 id="virtualization">Virtualization</h4>
<p><strong>Virtualization</strong>: provides software abstraction layer between hardware and OS and apps running on VM ‚Üí offers standardized platform for
applications<br />
<em>Hypervisor:</em> abstraction layer ist referred to as <em>hypervisor</em> (resource broker between hardware and VM, tranlates I/Os from VMs to physical
server devides, allows multiple OSs to coexist on a single physical host, allows live migration on VMs and other hosts)</p>
<ul>
  <li><em>Type 1 Hypervisor</em>: runs directly on hardware (high performance, strong isolation between VMs), synchronized access of VMs to hardware</li>
  <li><em>Type 2 Hypervisor</em>: runs on top of host OS (executed as app in user space), VMs provide virtual hardware to guest OS</li>
</ul>

<p><em>Container-based:</em> single kernel provides multiple instances (containers) of same host OS (no hypervisor involved, isolation enforced
by host OS kernel, apps in containers executed by host OS), kernel synchronizes access of containers to hardware</p>

<h4 id="service-function-chaining">Service Function Chaining</h4>
<p><strong>Service Function Chain (SFC)</strong>: ordered set of network functions (specifies ordering contrains that must be applied to flows), enables creation
of composite network services</p>

<p><strong>MPLS-based SFC</strong>: Services classifiers select appropriate service function chains, service function forwarders deliver packet to network
functions</p>

<h3 id="internet-congestion-control">Internet Congestion Control</h3>
<h4 id="basics-1">Basics</h4>
<p><strong>Shared (Network) Resources</strong>: general problem: multiple users use same resource, high
level objective with respect to networks (provide good utilization of network resources and
acceptable performance for users) ‚Üí Buffer or Drop?</p>

<p><strong>Congested Router</strong>: Assumption: no cumulative acks, all packets same length; Input interface
receives 4 times more traffic than can be forwarded on output interface ‚Üí 75% of packets
discarded</p>

<p><strong>Buffer</strong>: Router need buffers to cope with temporary traffic bursts, packets caan not be 
transmitted immediately ‚Üí buffer, buffer full ‚Üí packets dropped; buffers add latency, FIFO 
queues, end-to-end latency of packets:</p>
<ul>
  <li>Propagation delay</li>
  <li>transmission delay</li>
  <li>queueing delay (√ºberwiegt in vielen F√§llen)</li>
</ul>

<p><strong>‚Äúurspr√ºngliches‚Äù TCP</strong>: Connection establishment:3-way handshake (full duplex connection),
 connection termination: 4 way handshake (separately for each direction of transmission), data
 transfer: byte-oriented sequence numbers, go-back-N (positive cumulative acks, timeout), flow 
 control</p>

<p><strong>Congested Internet</strong>: drastic performance reduction of TCP (1986) ‚Üí series of congestion
collapses, goodput reduced about several orders of magnitude, routers dropped 10% of packets</p>

<p><strong>Throughput:</strong> amount of network layer data delivered in a time interval (pre-tax), 
aggregation of data flows <em>through</em> router/link</p>

<p><strong>Goodput:</strong> ‚Äúapplication-level‚Äù throughput (after-tax), amount of application data delivered 
in a time interval, retransmission doesn‚Äôt count, packets dropped not counted, what 
application receives, traffic at network level might be higher</p>

<p><strong>Knee</strong>: Load reaches network capacity, goodput stops increasing, buffers build up, end-to-end 
latency increases ‚Üí Network is <em>congested</em></p>

<p><strong>Cliff</strong>: traffic load increases beyond cliff, packets start to be dropped, goodput
decreased ‚Üí <em>Congestion collapses</em></p>

<p>‚Üí Initial TCP standard: entit simply doesn‚Äôt kow state of network, adjustment of sending
rate if TCP stream to capacity of network not possible</p>

<p><strong>Improved TCP Versions</strong>: Goal: estimate available network capacity to avoid overload 
situations, limit traffic instroduced to network accordingly; Traffic Sources: 
Receive feedback from network, apply congestion control ‚Üí system control and optimization 
problem</p>

<p><strong>Congestion avoidance</strong>: keep traffic load around knee</p>

<p><strong>Congestion control</strong>: prevent system from going over cliff</p>

<p>‚Üí Location of knee changes (difficult to predict): total network load and traffic pattern
matters ‚Üí typical distributed optimization problem</p>

<p><strong>Optimization Criteria</strong>: Network N with data sources, data rate of data source i: $r_i(t)$</p>
<ul>
  <li><em>Efficiency:</em> bottleneck link of source (link with lowest data rate), capacity C of bottleneck, 
set of sources that use the bottleneck link $A_i$: $\sum_{j in A_i} r_i(j)$ (But: how are
data rates distributed among sources?)</li>
  <li><em>Fairness:</em> fair allocation (all sources get equal allocation): $F(r_i,‚Ä¶,r_N) = 
\frac]{(\sum r_i)¬≤}{N(\sum r_i¬≤)}$, F = [0,1], totally fair = 1, totally unfair $= \frac{1}{N}$</li>
  <li><em>Convergence:</em> Responsiveness (Speed with wich $r_i$ gets to equilibrium at knee after starting
from zero), Smoothness (Oscillation arond equilirbium at steady state)</li>
  <li><em>Distributedness:</em> congestion control should operate in distributed manner (no central control, 
with complete knowledge, no need to know number of currently active sources)</li>
</ul>

<h4 id="types-of-congestion-control">Types of Congestion Control</h4>
<p><strong>Window-based Congestion Control</strong>: Congestion Control Window CWnd: max number of 
unacknowledged packets allowed per data stream, assumes each packet is acknowledged by
receiver, basic window mechanisms compares to sliding window, adjust sending rate of source
to bottleneck capacity ‚Üí self-clocking</p>

<p><strong>Rate-based Congestion Control</strong>: controls sending rate, implemented by timers (define
inter packet intervals), Problem: no cut off mechanism; e.g. UDP for audio/video streaming</p>

<h4 id="tcp-tahoe">TCP-Tahoe</h4>
<p><strong>Mechanisms</strong>: used for congestion control:</p>
<ul>
  <li>Slow Start</li>
  <li>Timeout</li>
  <li>Congestion avoidance</li>
  <li>fast retransmit</li>
</ul>

<p><strong>Congestion Signal</strong>: Retransmission timeout, Reception of duplicate acks ‚Üí begin of slow 
start</p>

<blockquote>
  <p>Must be valid: *LastByteSent - LastByteAcked ‚â§ min{cWnd, RcvWnd}</p>
</blockquote>

<p><strong>TCP Tahoe Algorithm</strong>: AIMD (additive increade, multiplicative decrease), Additive
increase of CWnd after receipt of acknoledgement, multiplicative decrease of CWnd if
packet loss is assumed; SSTresh (Slow Start Threshold)</p>
<ul>
  <li>CWnd &lt; SSThresh and ACKS received: slow start, CWnd += 1</li>
  <li>CWnd ‚â• SSThresh and ACKS received: congestion avoidance, Cwnd += 1/CWnd</li>
  <li>Timeout or 3 duplicate ACKS: slow start, CWnd = 1 MSS, SSTresh = max(FlighSize/2 * MSS)</li>
</ul>

<p><strong>Fast Retransmit</strong>: not every segment received out-of-order means congestion, wait until
retransmisson timer expires, then retransmit, BUT to be faster: retransmission after
receipt of specific number of duplicate ACKS e.g. 3</p>

<h4 id="analysis-of-improvements">Analysis of Improvements</h4>
<p>After observing Congestion Collapses the following mechanisms were introduced to the original TCP:</p>
<ul>
  <li>Slow-Start</li>
  <li>Round-trip time variance estimation</li>
  <li>Exponential retransmission timer backoff</li>
  <li>dynamic window sizing on congestion</li>
  <li>more aggressice reciever achknoledgement policy</li>
</ul>

<p>‚Üí packet conversation: keep TCP connection stable and achieve network stability</p>

<p><strong>Self-Clocking</strong>: is valid for any window-based system (TCP uses window-based flow control) <br />
<em>Basic Assumption:</em> Complete flow control window in transit (TCP: receive window RcvWindow), 
Bottleneck link with low data rate on path to receiver <br />
<em>Basic scenario:</em> graue K√§stchen = Pakete, Pakete vom schnellen Link auf langsamen Link geschickt ‚Üí Auswirkung auf Sendezeit (da
abh√§ngig von Datenrate) ‚Üí muss durch Bottleneck und braucht l√§nger ‚Üí <em>Inter Packet Gap</em> hei√üt L√ºcke die dadurch entsteht, bis 
neues Packet sich durch Bottleneck gequetscht hat. Dieser wird recht gro√ü und man wird ihn nichtmehr los. Packete werden
im Zeitraum des Inter-Packet-Gaps weitergeschickt. Ziel ist es Zustand zu erzielen und zu halten.</p>

<p><strong>Three Ways for Packet Conservation to fail</strong></p>

<p><em>1) Connection does not get to equilibrium</em></p>

<p><strong>Slow Start</strong> brings TCP connection into equilibrium if connection has just started or restart after assumption of congestion.
The idea of slow start is to no send the complete receive windoe (flow control) immediately, in case it is larger than
the buffer at the bottleneck, then it would drop segments. Gradually increase number of segments that can be send without receiving
an ACK <br />
<em>Approach:</em> Apply congestion window in addition to receive window, minimum of congestion and receive window can be sent (
Congestion Window: CWnd[MSS], Receive Window: RcvWindow[Byte]), new connection or congestion assumed: reset congestion window: CWnd = 1, 
incoming ACK for sent (not retransmitted) segment: increase congestion window by one ‚Üí exponential grows of CWnd</p>

<p>About MSS: refers to payload, that can be send in TCP segment that consist of TCP header (max. 60 bytes) and payload. With
IPv4 at least MSS of 536 byte must be supported</p>

<p><em>2) Sender injects new packet before an old packet has exited</em></p>

<p><strong>Retransmission Timer</strong>: <br />
<em>Assumption:</em> Complete receive window in transit</p>
<ul>
  <li>Alternative 1: ACK received, segment delivered and thus exited network ‚Üí conversation of packets fulfilled</li>
  <li>Alternative 2: Retransmission timer expired. Segment is dropped in the network ‚Üí conversation of packets fulfilled;
segment is delayed but not dropped ‚Üí conversation not fulfilled ‚Üí to short retransmission timeout causes connection to leave equilibrium</li>
</ul>

<p>‚Üí Good estimation of Round Trip Time essential for a good timer value</p>
<ul>
  <li>too small: unnecessary retransmissions</li>
  <li>too large: slow reaction to packet losses</li>
</ul>

<p><em>Estimation of Round Trip Time (RTT)</em>: RTT = wann kommt n√§chste Quittung an? ‚Üí timer-based measurement, timer resolution up to 500ms, 
requirements regarding timer resolutions vary (e.g. high resolution in high performance data center)</p>
<ul>
  <li>SampleRTT: time interval between sending a segment and reception of ACK, single measurement, retransmissions ignored (ACK can not be
associated with segment)</li>
  <li>EstimatedRTT: smoothed value across a number of measurements, observation: measured values can fluctuate heavily</li>
</ul>

<p>‚Üí apply exponential weighted moving average (EWMA), influence of each value becomes gradually less as it ages, unbiased estimator for 
average value: <em>EstimatedRTT = (1-$\alpha)*EstimatedRTT+ $\alpha$*SampleRTT</em> (Typical $\alpha$ = 0,125)</p>

<p><em>Retransmission Timeout (RTO)</em>: RTO = $\beta$ * EstimatedRTT</p>

<p><em>Estimation of Deviation</em>: Goal: avoid observed occasional retransmissions; Observations: Variation of RTT can greatly increase in higher
loaded networks: Deviation = (a-$\gamma$) * Deviation + $\gamma$ * |SampleRTT - EstimatedRtt|</p>

<p><em>Improved Retransmission Timeout (RTO)</em>: RTO = $\beta$ * EstimatedRTT  RTO = EstimatedRTT + $\beta$ * Deviation (Typical $\beta = 4, $\gamma$=0,25)
‚Üí Observation: Differences between RTT and RTO are smaller</p>

<p><em>Multiple Retransmissions</em>:</p>
<ul>
  <li>Problem 1: How large should timer interval be between two subsequent retransmissions of same segment? ‚Üí
<em>Exponential backoff</em> after each new retransmission RTO doubles (RTO = 2*RTO), maximum value should be applied (‚â• 60 seconds)</li>
  <li>Problem 2:To which segment does received ACK belong (original or retransmission)? ‚Üí <em>Karn‚Äôs Algorithm</em>: ACKs for
retransmitted segments are not included into calculation of EstimatedRTT and Deviation, timeout value is set to value calculated
by backoff algorithm until ACK of non-retransmitted segment received</li>
</ul>

<blockquote>
  <p>Timeouts are importatant to keep TCP connection in equilibrium, to avoid unnecessary retransmissions. Carefully tuned timers are important 
(apply EWMA and consider deviation)</p>
</blockquote>

<p><strong>Congestion Avoidance</strong>:
Consider <em>multiple</em> concurrent TCP streams ‚Üí how to adapt available path capacity?
Under the assumption that the TCP connection operaties in quilibrium, a packet loss is with high probability
caused by a newly started TCP connection (new connection requires resources on bottleneck router/link). Therfore
the load on existing TCP connections has to be reduced.</p>

<p><em>Congestion signal:</em> signals TCP senders that congestion is occurring or is about to occur (uses ACKs). An implicit
congestion signal needs no support from network. A missing ACK indicates a congestion situation (retransmission timeout). 
Duplicate ACKs are also used as congestion indication.</p>

<p><em>Additive increase/multiplicative decrease (AIMD):</em> Strategy to adjust traffic load</p>
<ul>
  <li>Multiplicatively decrease load in case a congestion signal was experienced. The Retransmission Timeout is
CWnd = y * CWnd with 0 &lt; y &lt; 1 (TCP Tahoe: y = 0.5)</li>
  <li>Additively increase load in case of no congestion signal is applicable. ACK received: CWnd += 1/CWnd</li>
</ul>

<p><strong>Additive increase Multiplicative decrease</strong>: is a general feedback control algorithm that is applied to congestion control.</p>
<ul>
  <li>Additive increase od data rate until congestion</li>
  <li>Multiplication decrease of data rate in case of congestion signal</li>
</ul>

<p>(img AIMD.png)</p>

<p><em>Asumptions:</em> explicit network feedback (increase/decrease load), system operates near the knee, system operation is 
synchronous and in discrete time steps</p>

<p><em>Fairness:</em> network with two sources that share a bottleneck link with capacity C, Goal bring system close to optimal point (c/2)</p>
<ul>
  <li>Efficiency Line: $r_1 + r_2 = C$ holds for all points on the line, points under the line reflect an underloaded system (‚Üí increase rate),
points above the line reflect an overloaded system (‚Üí decrease rate)</li>
  <li>Fairness Line: All sources with fair allocation ($r_1 = r_2$), multiplying with b does not change fairness. 
Jain‚Äôs fairness index: $F(r_1, r_2) = \frac{(r_1 + r_2)¬≤}{2(r_1¬≤ + r_2¬≤)}$</li>
  <li>Optimal Operating point: Intersection of efficiency line and fairness line
(img AIMD-fairness.png)</li>
</ul>

<p><strong>TCP Fairness</strong>: TCP connections compete for network resources. Goal all TCP connections receive equal share of bottleneck resource 
(non-zero). If n TCP connections share the same bottleneck it would be fair if each connection receives 1/n-th of the bottleneck capacity.
Both TCP connections have the same RTT and use the same MSS. Lost TCP segments are also detected instantly.</p>

<p>TCP Fairness refers to TCP connections. Therefore a user can open <em>multiple TCP connections</em> concurrently to <em>get more capacity</em>.
Furthermore the ACK generation of the receiver can influence resource allocation. A ‚Äúgreedy‚Äù receiver can send several ACKs, 
can send ACKs faster than it receives segments and can send duplicate ACKs. <br />
It is possible to open congestion window faster and consequently get more resources allocation. Inconsistencies of the TCP
specification can cause this: TCP sequence number countrs bytes, congestions window counts segments ‚Üí Attack would be impossible
if congestion window also counted bytes.</p>

<p>(img send-acks-fairness1.png)</p>

<p>The receiver acknowledged each segment in several pieces and congestion window opens fast (increases per received ACK)
The sender can also send ACKs faster/before data is received. Packet losses are unlikely, receiver anticipates successfull reception, since
ACKs are not a proof for receip of corresponding data. To solve this it requires changes in the protocoll or increasing loss possibility
of ACKs makes attack unprofitable.</p>

<p>(img send-acks-fairness2.png)</p>

<h4 id="tcp-reno">TCP Reno</h4>
<p>The TCP Reno concept differentiates between <em>Major congestion signal</em> (timeout of retransmission timer)
 and <em>minor congestion signal</em> (receipt of duplicate ACKs). The difference of TCP Tahoe in case of minor congestion
 signal is that Reno doesn‚Äôt reset to slow start (duplicate ACKs mean successful delivery of segments) and does <em>fast recovery</em>
 (controls sending of new segments until receipt of non-duplicate ACK). Major congestions signal still cause a slow start.</p>

<p><strong>Fast Recovery</strong>: is started on a receipt of a specified number of duplicate ACKs (usally 3). The idea ist that new segments should
continue to be send, even if packet loss is not yet recovered. The network load is reduced by halving the congestion window.
The first missing segment is fast retransmitted.</p>

<p><strong>Differences to TCP Tahoe:</strong> in congestion avoidance.</p>
<ul>
  <li>Timeout: slow start SSTresh = max(FlightSize/2, 2*MSS), CWnd = 1</li>
  <li>Fast recovery (3 dup Acks): retransmission of oldest unacknowledged segment</li>
</ul>

<p><strong>Evolution of Congestion Window</strong>: (img congwindreno.png)</p>

<p><strong>TCP Fairness</strong>: Sending identical ACKs multiple times causes interpretation of duplicate ACKs (one segment has left network ‚Üí
new one should be sent). TCP Reno is sending duplicate ACKs before/without receiving new segments. The sender sends a new segment
per received duplicate ACK. The self clocking continues and the congestion window grows. Remedy: retransmission timeout and reset
congestion window.</p>

<p>(img reno-fairness.png)</p>

<h4 id="periodic-model">Periodic Model</h4>
<p>For TCP Performance assesment interesting metrics:</p>
<ul>
  <li><em>Throughput:</em> Data that can be transferred in a certain time interval</li>
  <li><em>Latency:</em> Experienced Delay while sending data</li>
</ul>

<p><strong>Variables for analysing TCP</strong>:</p>
<ul>
  <li>X: Transfer rate measured in segments per time interval</li>
  <li>N: Number of segments</li>
  <li>A: Duration of a cycle</li>
  <li>RTT: Rount trip time [s]</li>
  <li>p: Loss probability of a segment</li>
  <li>MSS: Maximum segment size [bit]</li>
  <li>W: Value of a congestion measure in #MSS</li>
  <li>E[z]: Expeted value of variable z</li>
  <li>O: total amount of data to transfer [bit]</li>
  <li>D: data rate measured in bit per second [bit/s]</li>
</ul>

<p>Under the assumption of a long-term steady state behavior of TCP (without slow start, linear CWnd ‚Üí Congestion avoidance), a constant RTT and W,
periodically occuring losses that are detected through ACKs (no timeouts) and without retransmissions the progress of the congestion
window will be analysed. W is the value of the congestion window right before the packet loss is detected.</p>

<p>(img peridic-model.png)</p>

<p>The data rate when the segment loss occurs is $D = \frac{W MSS}{RTT}$, so a time of $\frac{w}{2} \cdot RTT$ is needed until congestions 
window reaches W again. Therefore the average data rate of a TCP connection is $D = \frac{0,75 W MSS}{RTT}$</p>

<p><strong>Round</strong>: A Round starts with the sending of W segments. After sendig these W segments, the sender cannot send any further segments before
receiving an ACK. This ACK marks the end of the current round and the beginning of the next round. The duration of a round corresponds to the RTT
and is independent of the window size, but the time to send a complete window is shorter than RTT.</p>

<p><strong>Cycle</strong>: A Cycle are (several) rounds until a segment loss is detected. After a loss, the next cycle starts.</p>

<p>(img round-cycle.png)</p>

<p>The minimal value of a congestions window is $\frac{W}{2}$ and it opens by one segment per round. That means the duration
of a cylcle is $\frac{W}{2} \cdot RTT$ and the number of delivered segments per cylce are $N = \frac{1}{p}$. 
The average transfer rate is $X = \frac{N}{t}$. The <em>Inverse Square-Root p Law</em> says that the intensity is inversely 
proportional to the square of the distance from the source of that physical quantity, which means: $X = 1,22 \frac{1}{RTT \sqrt{p}}$</p>

<h4 id="active-queue-management">Active Queue Management</h4>
<p>In the simple queue management a full buffer means, that the next segment must be dropped (tail drop). The problem here
is the synchronization. Segment of several TCP connections are dropped more or less at the same time.</p>

<p><strong>Active Queue Management (AQM)</strong>: The network gives an implicit notification of an arising congestion and reacts before
the queue gets overloaded. Routers can then drop segments before queue is completely filled up. The decision which segment
will be dropped is <em>random</em> that ensures more fairness. Consequently the average queue occupancy decreases and congestion
can be detected early.</p>

<p><em>Random Early Detection (RED)</em>: is an AQM algorithm. It does not drop segments if the queue occupancy is &lt; $q_{min}$ and 
does drop all segments if the occupancy is ‚â• $q_{max}$. For $q_{min}$ ‚â§ queue occupancy &lt; $q_{max}$ the probability of
dropping an incoming signal is linearly increasing with the queue occupancy. <br />
RED ist implemented in many routers/switches but rarely used. New AQM Algorithms are currently in development.</p>

<p><em>Explicit Congestion Notification (ECN)</em>: ist eine Erweiterung des Netzwerkprotokolls TCP/IP zur √úberlastkontrolle. 
Mittels ECN kann ein Router durch eine einfache Markierung eines Bits (genauer 2 bit) im IP-Header eine drohende √úberlast mitteilen.
ECN is based on queue occupandy and requires active queue management. The notifications must be issued before queue
is completely filled up. To <em>notify</em> congestion, the IP datagram is marked but not dropped and then forwarded to the
receiver. To <em>react</em> to the notified congestion, the sender receives the marked IP datagram and can then adjust congestion
control window accordingly. The notification takes place on layer 3 (IP).</p>

<p>(img ecn.png)</p>

<h3 id="ethernet-evolution">Ethernet Evolution</h3>
<h4 id="aloha-slotted-aloha">Aloha, Slotted Aloha</h4>
<p><strong>Aloha</strong>: was the first media access control (MAC) protocol for packet-based, wireless networks. MAC ensures time multiplex,
variable and random access. No previous sensing of medium an no announcement of intended transmission is possible. The access
to the medium is asynchonous. Therefore collisions are possible.</p>

<p>(img collision-aloha.png)</p>

<p><em>Collision detection:</em></p>
<ul>
  <li>Explicit: Confirmation of collision through higher layers, requires an additional communication channel</li>
  <li>Implicit: is used by aloha over satellite. The Satellite broastcasts received packets to all, the sending station
receives packet again after one RTT and can then check its correctness.</li>
</ul>

<p><em>Reaction to collisions:</em> is a Retransmission of the packets, but this should not introduce another collision. That‚Äôs why the
exact time of retransmission is <em>randomized</em>. After a certain amount of collisions, the sending is aborted.</p>

<p><em>Evalutation:</em> A collisions occurs if a previous packet from another sender has not been send completely 
of another system starts sending before transmission is done. With N active systems in the network, the probability p 
that a system starts sending, the probability that a collision occurs is $(1-p)^{N-1}$ and the probability for
a successfull transmission by any system $Np(1-p)^{2(N-1)}$. This is resulting in a maximum utilization $U_{max} = 0,18$</p>

<p><strong>Slotted Aloha</strong>: works like Aloha but uses time slots and a synchronized access only at the beginning of the time slog. It has
on average less collisions than normal Aloha.</p>

<p>(img slotted-aloha-coll.png)</p>

<p><em>Evalutation:</em> There are N active systems in the network. Each system starts to send with a probability p, so N-1 systems 
are not sending with a probabiliy of $(1-p)^{N-1}$. So the successful transmission of any system is $Np(1-p)^{N-1}$
The maximum utilization is $U_{max} = 0,36$</p>

<h4 id="csma-based-approaches">CSMA-based Approaches</h4>
<p><strong>Carrier Sense Multiple Access (CSMA)</strong>: is a media access control method that ckecks if the medium is free before starting to
send, so it is ‚Äúlistening before talking‚Äù.</p>
<ul>
  <li><em>CSMA/CD (Collision Detection):</em> The sending station can detect collisions by listening (usage e.g. Ethernet)</li>
  <li><em>CSMA/CA (Collision Avoidance):</em> The sending station assumes collisions when ACK is missing (usage e.g. WLAN)</li>
</ul>

<h4 id="ethernet-variants">Ethernet-Variants</h4>
<p><strong>Original Ethernet (IEEE 802.3)</strong>: uses MAC (time multiplex, variable, random access) and CSMA/CD with exponential backoff 
(Stauaufl√∂sungsmechanismus in Ethernet. Wird von Stationen im Ethernet eine Kollision erkannt, beenden diese Stationen ihre 
Sendung und versuchen sofort oder nach einer Slot-Time erneut ihre Sendung √ºber das Ethernet zu √ºbertragen.) The network 
topology was originally a bus topology with a data rate of 10 Mbit/s. Ethernet was wire based with a coaxial cable. The
standard consists of Layer 1 and Layer 2a (MAC Protocol).</p>

<p><em>CSMA/CD-based approach:</em> checks the medium, which is considered to be free if there is no activity detected for 96 bit times (=
Inter Frame Space). CSMA/CD is 1-persistent (Wenn das Medium als besetzt erkannt wird, wird gepr√ºft, bis es frei wird; wenn frei, 
wird gesendet (mit Wahrscheinlichkeit 1, d. h. immer)). The sender is doing collision detection. On detecting a collision, 
the sending will be aborted and a jamming signal (√úbertragung des anderen gezielt kaputt machen, damit er merkt, 
dass eine Kollision stattgefunden hat und Daten kaputt sing) will be sent (length 48 bit). Exponential backoff is for 
repeated transmissions.</p>

<p><em>Collision detection:</em> The sender is detecting a collision. This must happen before transmission is finished. The minimum 
duration for sending is the doubled maximum propagation delay of the medium. If the frames are shorter and therefore the sending time
it is not possible to detect a collision reliably (only CSMA, not CSMA/CD). To enforce the minimal frame length, the frame is
extended by the padding field (PAD).</p>

<p>(img ethernet-frames.png)</p>

<p><em>Utilization:</em> Under the Assumption that the Ethernet protocol works perfect without any interferences or errors and without
an overhead or processing time the maximum utilization is $U_{max} = \frac{throughput}{data rate} =\frac{1}{1+a}$. The parameter
a is used for performance evaluaion $a = \frac{propagation delay}{transmission delay}$. Two types of time intervals can be 
discriminated:</p>
<ul>
  <li>Transmission intervals: 1/(2a) time slots</li>
  <li>Collision intervals: collision or no transmissions</li>
</ul>

<p>(img ethernet-utilization.png)</p>

<p><strong>Fast Ethernet (IEEE 802.3u)</strong>: was introduced 1995 with a data rate of 100 Mbit/s (switchable between 10Mbit/s and 100 Mbit/s and 
automatic negotiation (protocol for automatic seletection of technical communication settings)), a star network topology (half duplex
and duplex links), medium access control (CSMA/CD for halb duplex links) that uses the same design as ethernet frames (collision detection
has to be possible) and a modified encoding.</p>

<p><em>Congestion and Flow Control:</em> With faster interfaces and switches as a central component, switches can be the performance bottleneck and frames are
temporarily buffered (buffer full ‚Üí frame has to be dropped). Loss recovery is done at transport layer (TCP) which is not performant.
Since buffer overflow and frame loss happens on layer 2, the resource bottleneck should be handled there. <em>Backpressure</em> is a workaround
for half duplex links. It enforces collision, CSMA/CD detects the collision and the sender aborts sending and repeats the frame (backoff).
This might cause a long delay. <br />
 Furthermore backpressure pretends the medium is used and sends a potentially correct bit sequenece, CSMA/CS notices that the medium is
 used and the sender is watining for the medium to be free. This is an implicit flow control. But it‚Äôs not possible with
 duplex links, since no CSMA/CD is used.</p>

<p><strong>Ethernet (IEEE 802.3x)</strong>: A <em>pause function</em> was standardized to stop sending on receiving a pause frame and implicitly continue after
a pause time that was given in the pause frame (multiple time for sending 512 bit) or explicitly continue when receiving a pause
frame with time=0. This does not solve longer overload in the network and only deals with short, local overload on a single link.</p>

<p>The pause function is a part of the newly introduced sublayer <em>MAC control</em> (Layer 2). All MAC control frames terminate on the MAC 
control sublayer or are generated by it. All other frames are passed from/to higher layers.</p>

<p>(img mac-control-frame.png)</p>

<p>Components should discover automatically which data rate/enconding is possible for the communication. The <em>Auto-negotiation function</em>
is between the end systems and a central node (hub, switch) to exchange 16-bit long messages to encode possible configurations.
It is transmitted as a sequence of tact and data pulses. The <em>Auto-negotiation function</em> is not for variants using glass fiber.</p>

<p><strong>1 Gigabit/s-Ethernet (IEEE 802.3z, IEEE 802.3ab)</strong>: Is almost the same Ethernet as standardized in IEEE 802.3u except the data rate 
 which has been upgraded to 1 Gbit/s but is still adjustable between 10Mbit/s and 100Mbit/s. Using half duplex links with
 a data rate of 1 Gbit/s makes it difficult to ensure collision detection with CSMA/CD. Therefore it it possible to either restrict
 the network size (max segment length of 10m) or change the minimum frame rate (efficient for a small amount of data). Since these
 changes are still not good enough, new concepts has been established:</p>
<ul>
  <li><em>Carrier extension:</em> ensures collision detection on fast links. It is increasing the transmission without increasing the 
 minimum length of the frames. The length of the time slot is not as long as the minimum length of a frame (minimum frame length: 512 Bit, 
 new time slot length: 512 byte).</li>
</ul>

<p>(img carrier-extension.png)</p>

<ul>
  <li><em>Frame bursting:</em> transmits short frames efficiently. Stations are permitted to send burst of frames directly following each other.
 The first frame has an extension if required (might be required for collision detection), the following frames are following (last
 frame has to start after at most 8192 Bytes)</li>
</ul>

<p>(img frame-bursting.png)</p>

<p><strong>10 Gigabit/s-Ethernet (IEEE 802.3ae (glass fiber), IEEE 802.3an (twisted pair))</strong>: Important characteristics of 
 10 Gigabit/s- Ethernet are a data rate of 10 Gbit/s, only point-to-point connections and only full duplex. It does no longer
 support old legacies like half duplex or hubs, CSMA/CD, no frame bursting or carrier extension and it does not require a MAC
 protocol. Jumbo frames with 9014 byte payload can be enabled optionally. It is the physical layer for locale networks (LANs) and 
 wide area networks (WANs). But it still requires improved coding mechanisms (interference becomes more problematic, signal-noise-ratio
 determines achievable data rate) and becomes technically challenging.</p>

<p><strong>40/100 Gigabit/s-Ethernet (IEEE 802.3ba)</strong>:40 or 100 Gigabit/s Ethernet is the fastes generation of Ethernet. It supports
  distances up to 40km and a multilane distribution (multiple parallel channels, different physical wires or different frequencies) and
  a virtual lane (distribute data stream over number of virtaul lanes)</p>

<h4 id="spanning-tree">Spanning Tree</h4>
<p><strong>Bridges</strong>: connect local networks (LANs) on layer 2. The filter function detaches
intra-network traffic in one LAN from inter-network traffic to other LANs, this increases
network capacity of big networks.</p>

<p>(img bridges.png)</p>

<p>There are two types of bridges:</p>
<ul>
  <li><em>Source-Routing bridges:</em> End systems add forwarding information in send packets. The 
Bridges forward the packet based in this information. Sending packets is not transparent for
the end system, it has to know the way.</li>
  <li><em>Transparent bridges:</em> The local forwarding decision takes place in each bridge. (
Forwarding information is store in the forwarding table). The end system is not involved in
forwarding decisions (existence of bridges is transparent for end systems). For each network
interface exists an own layer 1 and a MAC instance.</li>
</ul>

<p>(img transp-bridge.png)</p>

<p><strong>Spanning-Tree Algorithm</strong>: To ensure the network is established as a loop-free topology (packets must no loop endlessly)
 we use the <em>Spanning-Tree</em> Algorithm. To Forward packets, the switches have to learn the
 location of end systems (and store it in forwarding tables). The forwarding table is then
 used for filtering and forwarding of packets.</p>

<p>The <em>Spanning Tree</em> Algorithm organized the bridges as a tree topology (no loops possible), 
 where nodes are bridges or LANs and edges are connections between interfaces and LANs. In
 case the resoureces are not used optimally, it can be that bridges are not in the tree.
 Forwarding of packets is onl possible along the tree.</p>

<p>(img example-network.png)</p>

<p><em>Requirements</em> for using the bridge protocol:</p>
<ul>
  <li><em>Group address</em> to address al bridges in the network (MAC address)</li>
  <li><em>Unique bridge identifier</em> per bridge in the network</li>
  <li><em>Unique interface identifier</em> per interface in each bridge</li>
  <li><em>Path costs</em> for all interfaces of a bridge</li>
</ul>

<p>In the <em>Spanning Tree</em> Algorithm bridges send special packets, so called *Bridge Protocol
 Data Units (BPDUs). It contains the identifier of the sending bridge, the identifier of 
 the bridge that is assumed to be the root bridge and path costs of the sending bridge
 to the root bridge.</p>

<p><em>Implementation of Spanning Tree</em>: Determine the root bridge, then determine the root 
 interfaces for each bridge (calculate path costs to the root bridge, select the interface
 with the lowest costs) and then determine the designated bridge for each LAN (loop free). 
 A LAN can have multiple bridges. Select the bridge with the lowest costs on the root interface 
 (designated bridge, resolve equal costs over bridge identifier). The designated bridge is
 responsible for the forwarding of packets. Other bridges in the LAN will be deactivated
 (affected interfaces set to blocked).<br />
 Initially bridges have no topology information. Therefore all bridges think they are the
 root bridge (periodically sending BPDUs with itself as root bridge). As soon as the bridge
 receives a BPDU with a smaller bridge identifier it no longer assumes itself as the 
 root bridge (but the bridge with the smaller identifier). When it receives another BPDU
 wit an even smaller identifier, then this bridge is the new root bridge. If the bridge
 notices that it is not the designated bridge, it is no longer forwarding BPDUs.<br />
 The Algorithm is in a stable phase, if the root bridge periodically sends BPDUs (only
 active bridges forwar BPDUs), no more BPDUs are received (bridge again thinks its the 
 root bridge, algorithm starts again), after stabilization packets are forwarded over the 
 respective ports (based on forwarding table).</p>

<p>(img st-impl1.png st-impl2.png st-impl3.png st-impl4.png)</p>

<p><em>Forwarding of packets</em>: The forwarding table contains the information required for forwarding, 
 link destination address, outgoing port and timer, as well as static, created by network 
 administrator and dynamic entries, learned and forgotten during operation (Learning
 through incoming packets, forgetting based on timer (soft-state)). Packets with local
 destinations are not forwarded over the bridge to separate the traffic and increase 
 scalability.<br />
 If the bridge is receiving a packet with a <em>known destination</em>, that means the destination
  is identified by destination MAC address in the packet and matches an existing enstry in 
  the forwarding table, the packet will be sent over the respective port. <br />
  If the bridge is receiving a packet with a <em>unknown destination</em>, the packets will be 
  flooded, that means it is sent over all ports except the input port and the bridge learns
  the location of the source system by identifying the source MAC address in the packet and
  creating a new entry in the forwarding table. The source system needs to be reachable 
  over the input port.</p>

<p>(img forwarding-sptr-ex.png)</p>

<p><strong>Rapid Spanning Tree Protocol</strong>: (Wikipedia)[https://de.wikipedia.org/wiki/Rapid_Spanning_Tree_Protocol]:
  ‚ÄúDas Rapid Spanning Tree Protocol (RSTP) ist ein Netzprotokoll, um redundante Pfade in 
  lokalen Netzen zu deaktivieren, bzw. im Bedarfsfall (Ausfall einer Verbindung) wieder zu 
  aktivieren.
  Werden beim STP beim Ausfall einer Netzkomponente (Switch, Bridge etc.) noch s√§mtliche 
  Verbindungen unterbrochen, bis die neue Topologie berechnet ist, so fallen beim RSTP nur 
  die Pfade aus, die √ºber die defekte Komponente liefen. Ansonsten bleiben die bisherigen 
  Pfade bestehen, bis die Berechnung der neuen Topologie beendet ist. Die Umschaltung auf 
  die neue Topologie erfolgt dann sehr schnell. H√§ufig k√∂nnen die nicht-ausgefallenen 
  Verbindungen weiter bestehen bleiben, da lediglich einige zus√§tzliche Ports freigeschaltet
   werden, die zuvor wegen Redundanz deaktiviert waren.</p>

<p>Two new types of port states:</p>
<ul>
  <li><em>Alternate Ports</em> are ports with the best alternative path to the root bridge.</li>
  <li><em>Backup Ports</em> are also ports with alternative paths to a network that already has a
   connection. The bridge has two ports which connect to the same network.</li>
</ul>

<p>Every bridge sends <em>peridic BPDUs</em> (Hello-Timer = 2s) to the next hierarchy level in the
   tree. In case of a failure of a neighbor there are no BPDUs for 3 times.</p>

<p>Different types of ports:</p>
<ul>
  <li><em>Edge port:</em> Only end systems are connected (no loops possible)</li>
  <li><em>Point-to-Point port:</em> full duplex (only connects to  neighbors)</li>
  <li><em>Shared port:</em> connects to a network (no fast switching possible)</li>
</ul>

<p>(img rsp-ex.png)</p>

<h4 id="real-time-ethernet">Real time Ethernet</h4>
<p>Ethernet is a cheap technology and therefore used in manny new use cases (Industy automation, 
vehicles, music industry). Real time Ethernet is in these use cases not possible.</p>

<p><strong>Time-Triggered Ethernet (TT-Ethernet)</strong>: is used in control tasks for e.g. wind wheels and
vehicles. Requirements are support of time-triggered real time communication (collision free
sending), support of a data rate based communication and compatibility to normal Ethernet.</p>

<p>TT-Ethernet defines three <em>traffic classes</em>:</p>
<ul>
  <li>time controlled, high priority frames (time-triggered)</li>
  <li>rate limited data streams (rate-constrained)</li>
  <li>best-effort traffic: normal Ethernet frames, only send and relayed if no higher priority
frames are available</li>
</ul>

<p>(img tt-eth-classes.png)</p>

<p><strong>EtherCAT</strong>: is an Ethernet for control automation. Its topology is a logical ring, it needs
hardware changes and efficient handling of small data packets. It allows very time critical
applications.</p>

<p><strong>Audio Video Bridging (AVB)</strong>: is used for broadcasting, events (concerts, statium) and
vehicles. It need time synchronization between AVB stations (&lt; 1ms) and hardware changes.</p>

<h3 id="data-center-networking">Data Center Networking</h3>
<h4 id="high-level-view">High-Level View</h4>

<p><strong>Data Center</strong> typically has a large number of compute servers with virtual machine support
and extensive storage facilities. It uses off-the-shelf commodity hardware devices (
handels√ºbliche Hardware-Ger√§te) like switches with small buffers and a huge amount of servers
(&gt; 100.000). These devices fail regularly. Furthermore they should be extensible without 
massive reorganization, need to be reliable (requires redundancy) and highly performant 
(100Tbit/s, low latencies).</p>

<p>(img dc-simpl.png)</p>

<p><em>Top-of-Rack Switches (ToR)</em> are Ethernet switches that connect servers within a rack. 
Switches typically have small buffers. A rack has 42-48 rack units per rack.</p>

<p>(img tor.png)</p>

<p><em>Challenges</em> are to maintain <em>scalability</em>, to maximize throughput while minimizing latency
and cost. In case of failure to guarantee data integrity and service availability. Enhance
power efficiency and reduce operational costs.</p>

<p>A <em>Data Center Network</em> interconnects data center servers with each other and connects the
data center to the internet. There are <em>two types of traffic</em>: Between external clients and 
internal servers and between internal servers. <em>Border routers</em> connect the internal network
of the data center to the internet.</p>

<p><em>Routing/Forwarding within a Data Center</em> requires for example network efficiency, no
forwarding loops, a quick failure detection.</p>

<p>(img dc-forwarding.png)</p>

<p><strong>Typical Services</strong></p>

<p><strong>Infrastructure as a Service (IaaS)</strong>: providing virtual computing resources or virtual
network resources by cloud providers.</p>

<p><strong>Platform as a Service (PaaS)</strong>: allows customers to manage services (e.g. web apps) with
leased platforms from cloud providers without owning physical resources.</p>

<p><strong>Software as a Service (SaaS)</strong>: providing software services as needed. Customers do not
need to purchase software licenses.</p>

<p><strong>Storage as a Service (StaaS)</strong>: providing storage and sharing infrastructure by cloud
provider.</p>

<h4 id="network-topology">Network Topology</h4>
<p>The Tree-Based Topology is often used in data centers.</p>

<p>(img tree-based.png)</p>

<p><strong>Traffic Types</strong>
<em>East-west traffic</em> is between internal servers and server racks. It is the result of internal
applications like MapReduce and storage data movements.</p>

<p><em>North-south traffic</em> traffic between external cliens and internal servers.  It is is the 
result of external requests from the internet. North-south traffic may cause east-west 
traffic.</p>

<p><strong>Fat Tree Networks</strong></p>

<p><strong>Fat-Tree Networks</strong>: is a tree structure in which branches nearer the top of the 
hierarchy are ‚Äúfatter‚Äù (thicker, higher bandwidth) than branches further down the hierarchy.
It is a solution for the problem that switches only have a limited number of ports but we want
to connect a large number servers with it.</p>

<p>(img fat-tree-ex.png)</p>

<p>But in this topology switches need different numbers of ports and switches with high numbers
of ports are more expensive. The <em>k Pod Fat Tree</em> (below 4 pod fat tree) resolves this through
creating ‚Äúpods‚Äù (H√ºlle, Geh√§use) around switches. Each switch has k ports. To avoid re-numbering
of IP addresses when topology changes the entire topology uses layer 2 forwarding.</p>

<p>(img 4podfat.png kpodfatnumb.png)</p>

<p><em>Address Assignment</em>: for the private IPv4 address block 10.0.0.0/8</p>
<ul>
  <li>Pods: enumerated from left to right [0,k-1]</li>
  <li>Switches in a pod: IP address <em>10.pod.switch.1</em>
    <ul>
      <li>edge switches are enumerated from left to right [0, k/2 -1]</li>
      <li>enumeration continues with aggregation switches from left to right [k/2, k -1]</li>
    </ul>
  </li>
  <li>End hosts: IP address <em>10.pod.switch.ID</em>
    <ul>
      <li>Based on the IP Address of the connected edge switch</li>
      <li>IDs are assigned to hosts from left to right starting at 2</li>
    </ul>
  </li>
  <li>Core swiches: IP address <em>10.k.x.y</em>
    <ul>
      <li>k: number of pods</li>
      <li>x: starts at 1 and increments every k/2 core switches</li>
      <li>y: enumerates each switch in a block of k/2 core switches from left to rigt (starting 
  with 1)</li>
    </ul>
  </li>
</ul>

<p>(img address-ex-pod.png)</p>

<p><em>Advantages</em> of k Pod Fat Trees are the identical switches, cheap commodity (handels√ºbliche)
switches can be used and multiple equachl cost paths between any hosts. A <em>disadvantage</em> is
the high cabling complexity.</p>

<p><strong>Load Balancer</strong> distributes traffic to servers and also collects traffic from servers. It
provides NAT-like functions like translating private into public address spaces and hiding
internal structure to the outside. The hierarchical topology supports scalability and
redundant devices and links to increase reliability but it has many points of failure.</p>

<p>(img load-balancer.png)</p>

<p><strong>Clos Network</strong></p>

<p>A <strong>Clos Network</strong> is a multi-rooted tree that allows forming a large switch out of smaller
switches. Referred to as (m,n,r) switch with number of switches in the middle stage m, 
number of input/output ports n and number of input/output switches r.</p>

<p>(img clos.png)</p>

<p>In clos networks has three different levels of switches.
But clos networks are not limited to three levels. A recursive construction of clos networks 
with odd number of switches is possible through  replacing the middle switches with a three
level clos network. A Clos network is non-blocking if m ‚â• 2n - 1.</p>

<p>Three layers of switches:</p>
<ul>
  <li><em>Input switches:</em> ToR swithes directly connected to servers</li>
  <li><em>Middle switches:</em> Aggregation switches directly connected to ToR switches</li>
  <li><em>Output switches:</em> Intermediate switches connected to the aggregation switches</li>
</ul>

<h4 id="ethernet-within-data-centers">Ethernet within Data Centers</h4>
<p>Ethernet as a ‚Äúfabric‚Äù for data centers has to cope with a mix of different traffic types and
therefore needs <em>Prioritization</em>. <strong>Priority Code Point (PCP)</strong> is a field of the VLAN tag for
traffic differentiation. But it is not enough for bandwidth reservation.</p>

<p><strong>Data Center Bridging</strong></p>

<p><strong>Data Center Bridging</strong> is a unified, Ethernet-based solution for a wide variety of data
center aplcations. It is extending Ethernet with the following four functions.</p>

<p><em>Priority-based Flow Control</em> is an extension of flow control via PAUSE frame. Eight priority
levels are introduced using the VLAN tag (eight virtal links on one physical link). The 
pause time can be individually selected for each priority level that allows differentiated
quality of service.</p>

<p><em>Enhanced Transmission Selection</em> is introducing priority groups (PGs) to allow
bandwidth reservation. It guarantees a minimum data rate per PG. Unused capacity is usable by
other PGs.</p>

<p><em>Congestion control on Layer 2</em>: The Quantatized Congestion Notification (QCN) protocol 
estimates of the strengthof the congestion (Detection) and sends a feedback to congestion 
source via a special frame (Notification). The source can limit the transmission rate similar
to TCP (decrease transmission rate multiplicative and increase it again additive)</p>

<p><em>Data Center Bridge Exchange</em> Protocol (DCBX) detects the capabilites of the network and 
configueres the neighbors through sending periodic broadcasts to the neigbor, 
for example to enable priority-based flow control.</p>

<p><strong>Alternatives to Spanning Tree</strong></p>

<p>To gain more flexibility, in terms of network topology and usage 
and a better utilization of the total available capacity, data centers are using 
<em>routing algorithms in Layer 2</em>. <br />
The basic Procedure consists of two parts:
<em>Intermediate-System-to-Intermediate-System (IS-IS) protocol</em> uses link state rounting, 
doesn‚Äôt rely on IP address and supports multipath.<br />
The use of <em>tunneling</em> is encapsulated within the domain and adds a new header with addresses
that is used for forwarding.</p>

<p>(img l2f.png)</p>

<p><em>Alternative Concepts</em></p>

<p><em>Shortest Path Bridging (SPB)</em>: Every bridge in the LAN calculated shortest paths using MAC
address tabes. If the target is not known yet, the packet is forwarded via the shortest path 
tree. The packets are encapsulated in the LAN (MAC-in-MAC).</p>

<p><em>Transparent Interconnection of Lots of Links (TRILL)</em>: Routing Bridges implement TRILL. 
Each Routing Bridge is calculated in the LAN, the shortest routes to all Routing Bridges is
stored in a tree. These trees are sed for traffic with multiple destination. Forwarding
of the frame if target is unknown. The forwarding information base is quite small because it
only contains Routing Bridges and no end systems.</p>

<h4 id="tcp-within-data-centers">TCP within Data Centers</h4>
<p>For the use of TCP in Data Centers, relevant properties are:</p>
<ul>
  <li>low round trip times</li>
  <li>incast communication: servers answer to the client at the same time (synchronized)</li>
  <li>multiple patchs</li>
  <li>mix of long and short-lived flows</li>
  <li>virtualization</li>
  <li>ethernet as a ‚Äúfabric‚Äù</li>
  <li>commodity switches</li>
</ul>

<p>The <em>goals</em> are simultaneous support for low delays and high throughput, high utilization of
the infrastructure and low cost. At the same time data center should have the option to an
administrative control, homogenous components, backwards compatibility and seperation of 
traffic.</p>

<p><em>TCP Reno</em> is <em>not suitable</em> because of the requirement of large buffers and high end-to-end 
delay. Most TCP concepts for congestion control in data centers require changes is end systems
and switches.</p>

<p><strong>Incast Problem in Data Centers</strong></p>

<p><strong>TCP-Incast Problem</strong>: Incast ist a many-to-one communication pattern. It is common in 
applications such as web search and analytics. A Request is distributet to multiple servers
which are responding almost synchronously. The total numver of responses can overwhelm small
buffers in switches.</p>

<p>(img tcp-incast.png)</p>

<p><strong>Packet loss in Ethernet switches</strong>: Ports often share buffers because individual answers may 
be small. That‚Äôs why larger number of responses can overload a port, high background traffic
on the same port as incast or on a different port than incast can cause <em>packet losses</em>. 
Losses cause <em>TCP retransmission timeouts</em> and no further data can be received. Duplicate
ACKs cannot be generated.</p>

<p>(img tcp-retrans.png)</p>

<p><strong>Barrier Synchronization and Response Time</strong>: A client has a TCP connection to each of the
servers involved. Requests are sent synchronously to the servers which respond almost
synchronously. The application needs answers from all servers before the next query. The
consequence is that the slowest TCP connection determines the efficiency of the application. 
This effect, that the affected TCP instance must wait for the retransmission timeout, 
is called <em>Barrier Synchronization</em>. In this time the link is not used. The result are
long periods where the TCP connection cannot transfer data and the application is blocked.</p>

<p>To prevent these problems a <em>smaller minimum retransmission timeout</em> (ms ‚Üí ¬µs) and the
<em>desynchronization</em> in case of a full buffer as well as randomization to desynchronize 
retransmissions might be helpful.</p>

<h4 id="data-center-tcp">Data Center TCP</h4>
<p><strong>Data Center TCP (DCTCP)</strong>: achieves high burst tolerance, low latencies and high throughput
with commodity switches. DCTCP works with low utilization of queues without reducing the
throughput. DCTCP achieves the goal through responding to the strength of the congestion
and not to its presence if congestion occurs. The response based on presence would be too
strong in data center. Buffer underflow and a low throughput would be the result.</p>

<p><em>Explicit Congestion Notification (ECN)</em> is a very simple active queue management. If an
element is in the queue &gt; k the CE-Bit will be set.<br />
DCTCP sets the ECN echo flag only in ACKs for segments that were marked with <em>Congestion
Experienced</em>.</p>

<p><em>Benefits of DCTCP</em>:</p>
<ul>
  <li><em>Incast:</em> If the queue is build up over multiple RTTs, DCTCPs early reaction will help. If
the number of small flows is too large, no congestion controll will help to prevent segment
loss.</li>
  <li><em>Building the queue:</em> DCTCP reacts if the queue is longer than k. For bursts there is
more buffer space available.</li>
  <li><em>Buffer pressure:</em> Queues of loaded ports are kept small. The mutual influence among ports
is reduced.</li>
</ul>
:ET